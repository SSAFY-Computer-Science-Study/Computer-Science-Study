# 03장 명령어

### 3. 명령어

- 3-1 소스코드와 명령어
    - 고급언어와 저급언어
    - 컴파일언어와 인터프리터 언어
- 3-2 명령어의 구조
    - 연산코드와 오퍼런드
    - 주소 지정 방식

### 4. CPU의 작동원리

- ALU 와 제어장치
- 레지스터
- 명령어 사이클과 인터럽트

# 3-1 소스코드와 명령어

---

- 고급 언어
    - 개발자가 이해하기 쉽게 만든 언어
        - 컴파일 언어
        - 인터프리터 언어
- 저급 언어
    - 컴퓨터가 이해하고 실행하는 언어
        - 기계어
        - 어셈블리어
            - 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

- 컴파일 언어
    - 컴파일러에 의해 저급언어로 변환되는 컴파일 과정을 거치고 그 결과로 저급 언어인 ‘목적 코드’ 생성

# 3-2 명령어의 구조

---

<aside>
💡

기계어,어셈블리어도 전부 명령어이다.

</aside>

## 연산코드와 오퍼랜드(명령어 구조)

- **오퍼랜드**
    - 연산에 사용할 데이터 + 연산에 사용될 데이터가 저장된 위치
        - **대부분** 저장된 위치, 즉 메모리 주소나 레지스터 이름이 저장
        - 오퍼랜드 = 주소 필드라고 부르기도 함
- **연산 코드**
    - 명령어가 수행할 연산
    - 연산 코드 종류
        - 데이터 전송
            - 데이터를 메모리,CPU,스택에 저장하거나 가져오는경우
        - 산술/ 논리 연산
        - 제어 흐름 변경
            - 특정 주소에 대한 작업을 하는 경우
        - 입출력 제어
            - 특정 입출력 장치로부터 데이터를 읽거나 쓰는 경우

## 명령어 주소 지정 방식

- 유효 주소
    - 연산에 사용할 데이터가 저장된 위치
- 명령어 주소 지정방식
    - = 유효주소를 찾는 방법

- 굳이 명령어 주소 지정방식?
    - 명령어가 표현할 수 있는 데이터 크기는 고정되어있는데 오퍼랜드 개수 증가 시 표현할 수 있는 데이터 크기 한정적임
    - 메모리 주소를 오퍼랜드로 가지면 표현할 수 있는 데이터의 크기가 자유로워짐

### 메모리

- 즉시 주소 지정 방식
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 가장 간단한 형태
    - 연산에 사용될 데이터의 크기가 제한 됨
        - 하지만 빠름

- 직접 주소 지정 방식
    - 오퍼랜드 필드에 **유효 주소** 직접적으로 명시
    - 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦
- 간접 주소 지정 방식
    - 오퍼랜드 필드에 **유효주소의 주소**를 명시
    - 속도가 느림
        - cpu가 메모리에 접근하는 시간은 굉장히 속도가 느림

### 레지스터

- 레지스터 주소 지정 방식
    - 연산에 사용할 데이터가 저장된 **레지스터** 명시
    - 메모리에 접근하는 속도보다 레지스터에 접근하는것이 훨씬 빠름
    
- 레지스터 간접 주소 지정방식
    - 연산에 사용할 데이터를 **메모리**에 저장
    - 그 주소를 저장한 **레지스터**를 오퍼랜드 필드에 저장