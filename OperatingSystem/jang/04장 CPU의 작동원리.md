# 04장 CPU의 작동원리

<aside>
💡 CPU가 명령어를 실행하는 방식에 집중

</aside>

**CPU의 작동원리**

- ALU 와 제어장치
- 레지스터
- 명령어 사이클과 인터럽트

# 4-1 ALU와 제어 장치

---

## ✅ALU

- **받아들이는 정보**
    - **레지스터**를 통해 피연산자를 받아들이고
    - **제어장치**로부터 제어 신호를 받아들임
- **내보내는 정보**
    - 연산을 수행한 결과 : 특정 숫자나 문자, 메모리의 주소
        - 메모리에 저장되지 않고 일시적으로 **레지스터**에 ****저장됨
            - CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느림
    - ****플래그** :연산 결과에 대한 추가적인 상태정보
        - 제로 플래그
        
        의미: 연산 결과가 `0`이면 1로 설정됨.
        
        사용 예시: `5 - 5 = 0` → `ZF = 1` (결과가 0이므로)
        
        - 캐리 플래그
        
        의미: 덧셈 시 자리올림(캐리) 발생 or 뺄셈 시 자리내림(보로우) 발생 시 1로 설정됨.
        
        사용 예시: `255 (1111 1111) + 1 = 256 (1 0000 0000)` → `CF = 1` (8비트 초과)
        
        - 부호 플래그
        
        의미: 연산 결과가 음수면 1로 설정됨 (MSB가 1).
        
        사용 예시: `5 - 6 = -1 (1111 1111)` → `SF = 1` (음수이므로)
        
        - 오버플로우 플래그
        
        의미: 부호 있는 연산에서 값이 표현 범위를 초과하면 1로 설정됨.
        
        사용 예시: `127 + 1 = -128 (부호 비트 변경)` → `OF = 1`
        
        - 인터럽트 플래그
        
        의미: 인터럽트 요청을 허용할지 여부를 결정함.
        
        사용 예시: `IF = 1`이면 외부 인터럽트 허용, `0`이면 차단
        
        - 슈퍼바이저 플래그
        
        의미: 현재 실행 중인 코드가 커널 모드인지 사용자 모드인지 나타냄.
        
        사용 예시: `SF = 1`이면 커널 모드 (운영체제 코드 실행)
        

## ✅ 제어 장치

- 제어장치가 받아들이고 내보내는 정보에 집중

- **받아들이는 정보**
    - 클럭 신호
        - 클럭이란?
            - 컴퓨터의 시간 단위
            - 단 컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동한다x
            - 하나의 명령어가 여러 클럭에 걸쳐 실행 될 수 있다.
    - 해석 해야 할 명령어
    - 플래그 레지스터 속 플래그 값
    - 시스템 버스, 제어 버스로 전달된 제어 신호를 받아들임

- **내보내는 정보**
    - CPU **외부**에 전달하는 제어 신호
        - = 제어 버스로 제어 신호를 내보냄
            - 메모리에 전달
                - 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶을 때
            - 입출력 장치에 전달
    - CPU **내부**에 전달하는 제어 신호
        - ALU에 전달
            - 수행할 연산을 지시
        - 레지스터에 전달
            - 레지스터 간에 데이터를 이동시키거나 저장된 명령어를 해석하기 위해

- **제어 장치 주요 기능**
    - **명령어 해석(Instruction Decode)**
        - 메모리(RAM)에서 가져온 명령어를 분석해서 어떤 작업을 해야 하는지 판단해.
    - **제어 신호 생성(Control Signal Generation)**
        - CPU 내부의 ALU(연산 장치), 레지스터, 메모리 등 필요한 부품들에게 **언제, 무엇을 할지** 지시하는 신호를 보내.
    - **명령어 실행(Instruction Execution)**
        - 명령어에 따라 데이터를 읽거나, 연산을 수행하거나, 메모리에 저장하는 등의 작업을 진행해.
    - **순서 제어(Sequencing & Timing Control)**
        - 여러 하드웨어 부품이 **정해진 순서와 타이밍**에 맞춰 작동하도록 관리해.

- 구성 요소
    - **명령어 레지스터(IR, Instruction Register)** → 현재 실행 중인 명령어를 저장
    - **프로그램 카운터(PC, Program Counter)** → 다음에 실행할 명령어의 메모리 주소를 저장
    - **디코더(Decoder)** → 명령어를 해석해서 어떤 동작을 해야 하는지 결정
    - **컨트롤 신호 생성기** → CPU 내부 장치에 필요한 제어 신호를 만들어서 보내

# 4-2 레지스터

---

<aside>
💡프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장.
   레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름과 CPU내에서 무슨 일이 벌어지는이 어떤 명령어가 어떻게 수행되는지 알 수 있음.

</aside>

## 1. 프로그램 실행 과정

## 2.  특정 레지스터를 이용한 주소 지정방식

### ✅스택 주소 지정 방식

- **스택을 이용한 데이터 접근 방식에 집중**
- **데이터 접근 방식**
    - 스택 포인터 (SP) 이용
        - 현재 스택의 최상위 주소를 가리킴
    - PUSH 연산
        - 데이터를 스택에 저장
        - SP 값 감소 (스택이 아래로 확장될 경우)
    - POP 연산
        - 스택에서 데이터를 가져옴
        - SP 값 증가
    - 명령어 실행 시, 스택을 통해 피연산자를 자동으로 가져옴
- **장점**
    - 명령어가 짧아짐 (명시적 주소 필요 없음)
    - 연산자가 자동으로 스택에서 처리됨
    - 서브루틴 호출 및 복귀에 유용
- **단점**
    - 임의 접근이 어렵고 순차적 접근만 가능
    - SP 관리가 중요하며, 오버플로우 발생 가능

### ✅변위 주소 지정 방식

- 종류
    - 상대 주소 지정 방식
    - 베이스 레지스터 주소 지정 방식
- **기본 주소와 변위를 활용한 방식에 집중**

- **상대 주소 지정 방식**
    - **프로그램 카운터 (PC) 기반**
        - 명령어에 지정된 변위를 PC 값과 더해 유효 주소 계산
    - **특징**
        - 상대적인 위치를 사용하여 코드 이동성이 높아짐
        - 실행 중인 프로그램이 다른 위치에 로드되어도 정상 작동 가능
- **베이스 레지스터 주소 지정 방식**
    - **베이스 레지스터 이용**
        - 명령어에 지정된 변위를 베이스 레지스터 값과 더해 유효 주소 계산
    - **특징**
        - 운영체제에서 메모리 보호 및 다중 사용자 환경에 유리
        - 특정 레지스터를 기준으로 주소를 계산하므로 유연성 증가

# 4-3 명령어 사이클과 인터럽트

---

<aside>
💡명령어 사이클: 하나의 명령어를 처리하는 정형화된 흐름
  인터럽트: CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만 , 간혹 흐름이 끊어지는 상황 발생

</aside>

## 명령어 사이클

- CPU 는 정해진 흐름에 따라서 하나의 명령어를 처리

## 인터럽트

- 동기 인터럽트
- 비동기 인터럽트

### 동기 인터럽트

- CPU에 의해 발생하는 인터럽트
- = 예외(exception)

### 비동기 인터럽트

- 주로 입출력 장치에 의해서 발생
- 일반적으로 비동기 인터럽트 = 인터럽트
- 하드웨어 인터럽트

- **하드웨어 인터럽트 처리 순서**
    1. 입출력 장치는 cpu에 **인터럽트 요청 신호**를 보냄
    2. cpu는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
    3. 인터럽트 플래그를 통해 현재 인터럽트를 받을 수 있는 지 여부 확인
    4. CPU는 지금까지의 작업을 백업
    5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재