# 05. CPU 성능 향상 기법


## 05-1. 빠른 CPU를 위한 설계 방법
> `클럭`   `코어`    `멀티코어`    `스레드`    `멀티스레드`
>

<br>

### 클럭

> 
> 1. 컴퓨터 부품들은 **`클럭 신호`**에 맞춰 일사분란하게 움직인다.  
> 2. CPU는 **`명령어 사이클`**이라는 정해진 흐름에 맞춰 명령어를 실행한다.  
>   
> ⇒ 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복하고, 더 빠르게 작동한다.  
> ⇒ **클럭 속도가 높은 CPU**는 일반적으로 **성능이 좋다.  
> but,** 클럭 속도를 너무 끌어올리면 발열 문제가 심각해진다.  

- **클럭 속도**
    - 클럭 속도 = **CPU 속도 단위**
    - 헤르츠(Hz) 단위로 측정 → 1초에 클럭이 몇 번 반복되는지
    - 클럭 신호가 **1초에 *n* 번** 반복된다면 클럭 속도는 `*n*Hz`[헤르츠]
        - **예) 실제 CPU 클럭 속도는** 기본 속도(Base): 2.5GHz(25억번), 최대 속도(Max): 4.9GHz

> ### ✅ 클럭 속도는 일정하지 않다  
> 
> 클럭 속도는 매번 일정하게 유지되지 않는다.  
> CPU 속도에 Base 속도, Max속도로 나눠져 있듯이, CPU는 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않으면 유연하게 속도를 낮춘다.
>   
>**최대 클럭 속도를 강제로 더 끌어올리는 기법**을 `오버클럭킹` *overclocking*이라고 한다.  

<br>


### 코어와 멀티코어

클럭 속도를 높이는 방법 외에 **CPU 성능을 높이는 방법**에 대표적인 해결책으로는 **CPU 코어와 스레드 수를 늘리는 방법**이 있다.

- **코어 *core***
    
    ![Image](https://github.com/user-attachments/assets/9b9ee0ef-4e1b-4dc7-8104-c5ade5e0f674)
    
    **CPU**는 **`명령어를 실행하는 부품`**이라고 소개했지만, 오늘날 CPU는 많은 기술적 발전을 거듭하였고, 그 결과 **CPU 내부**에는 `명령어를 실행하는 부품`을 얼마든지 만들 수 있게 되었음.  
    즉, 이러한 부품을 오늘날 **`코어** *core*` 라고 함. **CPU**는 **`명령어를 실행하는 부품(코어)을 여러 개 포함하는 부품`**으로 범위가 확장됨 
    
- **멀티 코어 *multi-core***
    - 코어를 여러 개 포함하는 CPU를 **`멀티코어 CPU`** *multi-core CPU* 또는 **`멀티코어 프로세서`**라고 함
    - 이는 CPU 내에 명령어를 처리하는 일꾼이 여러 명 있는 것과 같음
    - 멀티 코어의 처리 속도는 단일 코어보다 빠름
        - **예)** 클럭 속도 2.4GHz인 단일 코어 CPU보다 클럭 속도 1.9GHz인 멀티 코어 CPU가 빠름
    - 코어의 개수에 따라 싱글코어, 듀얼코어, 쿼드 코어 등으로 나뉨
    
    > ### ✅ 코어를 늘리면 연산 처리 속도도 코어 수에 비례하여 증가할까?  
    >   
    > **아니다!**  
    > 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않는다.  
    > 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다. 예를 들어 100인분 요리를 1명의 요리사 vs 100명의 요리사라면 속도 차이가 크겠지만, 4인분 요리를 5명의 요리사 vs 10명의 요리사라면 큰 의미는 없음.
    >    
    > ⇒ 중요한 것은 **코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐**이고 **그에 따라 연산 속도는 크게 달라진다.**  
    >  

<br>

### 스레드와 멀티스레드 `10장`

- **스레드 *thread***
    - 사전적 의미 = **`실행 흐름의 단위`**
    - **CPU에서 사용되는 스레드**와 **프로그래밍에서 사용되는 스레드**는 용례가 다름!!
    - **CPU**에서 사용되는 **`하드웨어적 스레드`**와 **프로그램**에서 사용되는 **`소프트웨어적 스레드`**를 구분   
    ![Image](https://github.com/user-attachments/assets/fd9a86a0-f970-47fd-bcd9-d8098cf15541)

<br>

### **하드웨어적 스레드**

- **`하나의 코어(❓)**가 **동시에 처리**하는 **명령어** 단위`를 의미
- 우리가 앞에서 다룬 CPU는 **1코어 1스레드 CPU** = 명령어를 실행하는 부품이 하나 있고, 한 번에 하나의 명령어를 실행
- 여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있음
    - **2코어 4스레드 CPU** = 2개의 코어, 한 번에 네 개의 명령어 처리
        - **이는 코어 하나당 2개의 하드웨어 스레드를 처리한다는 뜻**
    
    ![Image](https://github.com/user-attachments/assets/9be71232-3589-4149-b08b-a6ac2b0f8913)
    
- **하나의 코어로 여러 명령어를 동시에 처리하는 CPU = `멀티스레드 CPU`** *multithread CPU* 또는 **멀티스레드 프로세서**
    - 인텔의 멀티스레드 기술은 **하이퍼스레딩***hyper-threading*이라고 불림
- **예)** 8코어 16스레드? → 8개의 명령어 해석 부품이 있고, 코어 하나 당 2개의 하드웨어 스레드 처리

<br>

### **소프트웨어적 스레드**

![Image](https://github.com/user-attachments/assets/0b736010-862d-40ee-9265-db78476973c6)

- **`하나의 프로그램**에서 **독립적**으로 **실행**되는 단위`
    - 프로그래밍 언어, 운영체제 등에서 접하는 일반적인 스레드 개념
- 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있음
    
    ![Image](https://github.com/user-attachments/assets/1c507622-f28b-468d-bc17-5ab105e2ef0f)
    
- 한 번에 하나씩 명령어를 처리하는 **1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있음** → 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행할 수 있음

<br>


### **멀티스레드 프로세서**

- **하나의 코어로 여러 명령어를 동시에 처리하는 기술**인 **`하드웨어적 스레드`**를 중심으로 학습하자!
- 멀티스레드 프로세서를 설계하는데 가장 큰 핵심은 **레지스터**임
- 하나의 코어로 여러 명령어를 동시에 처리하도록 하려면 PC, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 **하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러 개** 가지고 있으면 됨! ⇒ **`레지스터 세트`**
    
    ![Image](https://github.com/user-attachments/assets/7cb3d3db-f6f2-4d2d-bfaf-52b92e4571dd)
    
    - 레지스터 세트가 여러 개라면 여러 개의 명령어를 처리하기 위해 필요한 처리 정보를 따로 기억할 수 있음  
    - → 따라서 **ALU와 제어장치가 각각의 레지스터 세트에 저장된 명령어를 해석하고 실행하면 하나의 코어에서 여러 개의 명령어가 동시에 실행**
- 하드웨어 스레드를 이용해 하나의 코어로도 여러 명령어를 동시에 처리할 수 있음
but, **메모리 속 프로그램 입장에서 봤을 때 하드웨어 스레드**는 마치 ‘**한 번에 하나의 명령어를 처리하는 CPU**’나 다름 없음
    - **2코어 4스레드**
        
        ![Image](https://github.com/user-attachments/assets/f2b364b7-f7cc-4f2a-85c0-35016a9957c7)
        
        - 한 번에 4개의 명령어를 처리 = 프로그램 입장에서 한 번의 하나의 명령어를 처리하는 CPU 4개
        - **프로그램 관점에서는 스레드가 하나의 CPU처럼 보여서** 하드웨어 스레드를 **`논리 프로세서** *logic processor*` 라고도 함

> **✅ 총정리**  
>  
> 1. **코어** - 명령어를 실행하는 하드웨어 부품  
> 2. **스레드** - 명령어를 실행하는 단위  
> 3. **멀티코어 프로세서** - 코어가 두 개 이상 있는 CPU  
> 4. **멀티스레드 프로세서** - 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU   

<br>
<br>

## 05-2. 명령어 병렬 처리 기법
> `명령어 파이프라이닝`   `슈퍼스칼라`   `비순차적 명령어 처리 기법`
> 

빠른 CPU를 만들려면 클럭 속도를 높이고 멀티코어, 멀티스레드를 지원하는 것도 중요하지만, CPU가 놀지 않고 작동하게 만드는 것도 중요하다.

**명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는** 기법인 **`명령어 병렬 처리 기법 *ILP; Instruction-Level Parallelism*`**에 대해 알아볼 것

대표적인 명령어 병령 처리 기법에는 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있음

<br>


### 명령어 파이프라이닝 *instruction pipelining*

![Image](https://github.com/user-attachments/assets/4823bf36-7f7d-4b00-a4b1-15b9e4927fd5)

하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어보자.

- **명령어 처리 과정**
    - **클럭 단위**로 나누면
    1. 명령어 인출 *Instruction Fetch* 
    2. 명령어 해석 *Instruction Decode*
    3. 명령어 실행 *Execute Instruction*
    4. 결과 저장 *Write Back*
    - 같은 단계가 겹치지 않는다면 **CPU는 각 단계를 동시에 실행할 수 있다!**
    - CPU는 한 명령어를 인출하는 동안 다른 명령어를 실행할 수 있음
        
        ![Image](https://github.com/user-attachments/assets/2b89b47a-3b28-4d31-865e-3ce1c241f9c1)
        
    - 명령어 파이프라이닝을 사용하지 않은 경우
        - 4개의 명령어 실행에 16클락
        - 파이프라이닝 → 7클락
        
        ![Image](https://github.com/user-attachments/assets/68eb0112-8a97-4922-94f2-c9c97d2fb43f)
        
- 공장 생산 라인과 같이 **명령어**들을 **명령어 파이프라인**에 넣고 **동시에 처리하는 기법**을 **`명령어 파이프라이닝`**이라고 함
- **파이프라인 위험** *pipeline hazard*
    - 파이프라이닝이 높은 성능을 가져오지만, **성능 향상에 실패**하는 특정 상황를 말함
    1. **데이터 위험** *data hazard*
        - 병렬적으로 처리하고자 하는 명령어 간에 **데이터 의존성**이 있을 경우 발생
        - 데이터 의존적인 두 명령어를 동시에 실행하려고 하면 파이프라인이 제대로 작동 x
        - **예)** 이전 명령어를 끝까지 실행한 후 변조된 결과값을 이후 명령어에서 사용할 경우
            - 명령어 1: R1 ← R2 + R3
            - 명령어 2: R4 ← R1 + R5 //위의 결과값을 사용
    2. **제어 위험** *control hazard*
        - 분기 등으로 인한 **프로그램 카운터의 갑작스러운 변화**에 의해 발생
        - PC는 **현재 실행 중인 명령어의 다음 주소**로 갱신됨
        - but, 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 PC 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 인출해서 처리 중이었던 명령어는 아무 쓸모가 없어짐
            
            ![Image](https://github.com/user-attachments/assets/034e5444-f6ce-457c-bb27-b68154f2e379)
            
        - **분기 예측** *branch prediction* 기법(프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출)을 통해 완화할 수 있지만 한계는 있음
    3. **구조적 위험** *structural hazard*
        - 병렬적으로 처리하고자 하는 명령어들이 동시에 ALU, 레지스터 등과 같은 **동일한 CPU 부품을 사용**하고자 할 때 발생
        - **자원 위험** *resource hazard* 라고도 함


<br>


### 슈퍼스칼라 *superscalar*

![Image](https://github.com/user-attachments/assets/5680fa47-ee92-4050-a968-32b8221c8e00)

- **CPU 내부에 `여러 개의 파이프라인`을 포함한 구조**

![Image](https://github.com/user-attachments/assets/9e3f9b89-5400-47ea-b73f-f62cdd38849c)

- 이러한 방식의 처리가 가능한 CPU를 **슈퍼스칼라 CPU** 또는 **슈퍼스칼라 프로세서**라고 함
- 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 함. 가령 멀티스레드 프로세서는 한 번에 여러 명령어를 인출하고, 해석하고, 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있음 `🔥**추가 개념**`
- 슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례하여 처리 속도가 빨라지지만, 파이프라인 위험 등의 이유로 실제로는 비례하지 X
- 이 때문에 슈퍼스칼라 방식은 하나의 파이프라인을 사용할 때에 비해 파이프라인 위험을 피하기가 더 까다로워 고도의 설계 필요

<br>

### 비순차적 명령어 처리 *OoOE; Out-of-Order execution*

오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법

- 파이프라인의 중단을 방지하기 위해 명령어를 **순차적으로 실행하지 않는 기법 =** 명령어의 `합법적인 새치기`
- **순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법**
- 비순차적 명령어 처리를 위해서는 어떤 명령어들이 서로 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는지 판단 필요
- 위에서의 2가지 방법은 모두 여러 명령어의 순차적인 처리를 함
but, 파이프라인 위험과 같은 예상치 못한 이유로 이따금씩 명령어는 곧바로 처리되지 못하고, 파이프라인은 멈춰버리게 됨
- **예제**
- M(N) ← K : 메모리 N번지에 K를 저장하라
    
    ![Image](https://github.com/user-attachments/assets/dcbecae8-1228-40c3-b1d7-f45c090bfce5)
    
    - 3번은 1, 2번을 기다려야 함
    - 2번 끝날 때까지 3, 4, 5, 6은 기다림
    
    ![Image](https://github.com/user-attachments/assets/7bc44830-4824-4c32-92b3-3864ca0a7f51)
    
    - 서로 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어가 있음
        
        ![Image](https://github.com/user-attachments/assets/68297d8c-e783-4615-bea0-8795cd5e340c)
        
        ![Image](https://github.com/user-attachments/assets/15af9af8-6422-434a-a255-7ad1cb4631a8)
        
    - 따라서 **순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법** = **비순차적 명령어 처리 기법**
- **다른 예제**

![Image](https://github.com/user-attachments/assets/15fef309-fb27-4787-8447-992fc2ee6170)

<br>
<br>

## 05-3. CISC와 RISC
> `ISA`   `CISC`   `RISC`
> 

명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 **명령어가 파이프라이닝에 최적화**되어 있어야 함. 

**파이프라이닝 하기 쉬운 명령어란 무엇일까?**

CPU의 언어인 ISA와 각기 다른 성격의 ISA를 기반으로 설계된 CISC와 RISC를 학습해보자

<br>

### 명령어 집합 *ISA; Instruction Set Architecture*

- **명령어**는 기본적으로 연산 코드와 오퍼랜드로 구성되어 있지만, 구체적인 구조, 사용 가능한 연산, 주소 지정 방식 등은 **CPU마다 차이가 있음**
- `CPU가 이해할 수 있는 명령어들의 모음`을 **명령어 집합** *instruction set* 또는 **명령어 집합 구조** *ISA; Instruction Set Architecture* 라고 하는데, CPU마다 ISA가 다를 수 있음
- **ISA**가 다른 **CPU**끼리는 어셈블리어가 다르며 서로의 명령어를 이해할 수 없음
- → ISA는 **`CPU의 언어`**
    
    ![Image](https://github.com/user-attachments/assets/db559092-6b9b-447f-a716-04f724a97660)
    
- ISA가 다르면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터 종류 및 개수, 메모리 관리 방법 등 많은 것이 달라지고 → CPU 하드웨어 설계에도 영향을 미침

병렬 처리 기법을 도입하기 유리한 현대 ISA의 양대 산맥인 CISC와 RISC


<br>


### CISC *Complex Instruction Set Computer*

- **`복잡한 명령어** 집합을 활용하는 컴퓨터(CPU)`
    - 예) x86, x86-64
- 명령어의 형태와 크기가 다양한 **`가변 길이 명령어`** 를 활용
    
    ![Image](https://github.com/user-attachments/assets/847b1257-2f61-4cbb-88e6-4018b636464e)
    
- 메모리에 접근하는 주소 지정 방식도 다양하며, 특별한 상황에서만 사용되는 방식도 있음
- **장점**
    - 다양하고 강력한 명령어를 활용하면 **상대적으로 적은 수의 명령어로도 프로그램을 실행**시킬 수 있음  
    = **컴파일된 프로그램의 크기가 작다 (`메모리 절약`)**
    = 같은 소스코드를 컴파일해도 **CPU마다 생성되는 실행파일의 크기**가 다를 수 있다!
    - 이러한 장점으로 메모리를 최대한 아껴야했던 시절 인기가 많았음
- **단점**
    
    ![Image](https://github.com/user-attachments/assets/e39f579a-d10b-4066-98dd-c4cc163c8d0f)
    
    - 명령어의 복잡한 기능 때문에 **명령어의 크기 및 수행 시간이 일정하지 않으며, 명령어 하나를 실행(한 단계)하는데 여러 클럭 주기를 필요**로 하는 경우도 있음
        - → 이러한 비 규격화로 인해 **`명령어 파이프라인 구현의 걸림돌`**
        - 즉 **현대 CPU가 높은 성능**을 내기 위해 **명령어 파이프라인**은 핵심기술!
    - 복잡하고 다양한 명령어가 있지만, 사용빈도가 낮음
        - 자주 쓰이는 20%의 명령어가 전체 명령어의 80%가량을 차지


<br>

### RISC *Reduced Instruction Set Computer*

CISC의 한계로부터 얻은 교훈을 기반으로 만들어짐

> 1. 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 한다. 원활한 파이프라이닝을 위해 **`명령어 길이와 수행 시간이 짧고 규격화`**되어 있어야 한다.
> 2. 어차피 자주 쓰이는 명령어만 줄곧 사용된다. 복잡한 기능을 지원하는 명령어를 추가히기보다는 `자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것`이 중요하다.

- **예)** ARM
- RISC는 CISC에 비해 **명령어 종류가 적음**
- 규격화된 적은 수의 **`고정 길이 명령어`**를 활용
- **규격화된 명령어**, **1클럭 내외로 실행되는 명령어**
→ `파이프라이닝에 최적화`
- 메모리에 직접 접근하는 명령어를 `load`, `store` 두 가지로 제한할 만큼 **메모리 접근을 단순화 하고 최소화를 추구** → CISC보다 주소지정 방식의 종류가 적은 경우가 많음
    - → RISC를 **load-store 구조**라고도 함
- 메모리 접근보다 **레지스터를 적극 활용**하여 레지스터를 이용하는 연산이 많고, 범용 레지스터의 개수도 많은 편
- 다만 사용 가능 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 많은 명령으로 프로그램을 작동

![Image](https://github.com/user-attachments/assets/16cdfcfd-755c-46ef-bbca-a904f1dc36cb)

## 추가 개념

> ### ✅ 슈퍼스칼라 vs 멀티스레딩  
>
> 슈퍼스칼라(Superscalar)와 멀티스레드(Multithreading) 프로세서 구조는 독립적인 개념이지만, 서로 결합하여 성능을 극대화할 수 있음  
>   
> - **슈퍼스칼라**는 한 클럭 주기 내에 여러 명령어를 동시에 인출하고, 해석하며, 실행할 수 있는 능력을 갖춘 프로세서 아키텍처임. (파이프라인이 여러개) 즉, 슈퍼스칼라는 프로세서 내부에서 여러 개의 명령어를 병렬로 처리할 수 있는 구조를 의미. 슈퍼스칼라 프로세서는 여러 개의 실행 유닛(execution units)을 갖고 있어, 각 유닛이 동시에 다른 명령을 처리할 수 있도록 설계됨.  
> - **멀티스레딩**은 프로세서가 여러 스레드를 동시에 처리할 수 있는 기능을 말함. (레지스터 유닛이 여러개) 멀티스레딩을 지원하는 프로세서는 각 스레드를 독립적으로 실행하며, 이는 성능을 향상시킬 수 있지만, **반드시 슈퍼스칼라 구조를 필요로 하지 않음!!!!!!!**  
>   
> ### 결론  
>   
> - **슈퍼스칼라가 전제냐 멀티스레드가 전제냐**의 질문에서, **슈퍼스칼라**는 **하드웨어 아키텍처적 특성**이고, **멀티스레딩**은 **소프트웨어적 측면임**. 즉, 슈퍼스칼라는 프로세서가 동시에 여러 명령을 처리하는 능력에 대한 것이고, 멀티스레딩은 동시에 여러 프로그램 흐름(스레드)을 처리할 수 있는 기능.  
> - **결론적으로**: 슈퍼스칼라는 멀티스레드 프로세서를 포함할 수 있지만, **슈퍼스칼라는 멀티스레딩을 반드시 전제로 하지는 않음.** 슈퍼스칼라 프로세서는 멀티스레딩을 지원할 수도 있고, 단일 스레드 작업에도 여러 명령을 동시에 처리 가능.  
>   
> ⇒ 멀티스레딩 프로세서가 슈퍼스칼라 구조를 사용할 수 있다!  
