# 11. CPU 스케줄링
## 11-1. CPU 스케줄링 개요

> `CPU 스케줄링`   `우선순위`   `스케줄링 큐`   `준비 큐`   `대기 큐`   `선점형 스케줄링`   `비선점형 스케줄링`
> 

> **운영체제**는 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하기 위해
**CPU 스케줄링** *CPU scheduling* 을 수행 - (컴퓨터 성능과도 연결)
> 

<br>

### 프로세스 우선순위

프로세스들이 차례대로 돌아가며 CPU를 사용하게 한다면 우선수위를 고려하지 못하므로 비효율적

프로세스마다 **우선순위** *priority* 가 다르기 때문에 일반적으로 운영체제는 이를 반영하여 스케줄링함

- **프로세스의 실행 과정**
    - 대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행
    - 실행 상태와 대기 상태를 반복하며 실행
        
        ![image](https://github.com/user-attachments/assets/a678cbf2-7693-4703-b19d-5c464da54cdd)
        
    - 다만, 프로세스 종류마다 입출력장치, CPU를 이용하는 시간의 양에 차이가 있음
- **프로세스의 종류**
    - **`입출력 집중 프로세스`** *I/O bound process*
        - 입출력 작업이 많은 프로세스
        - 대표적으로 비디오 재생이나 디스크 백업 작업 등
        - 실행 상태보다는 입출력을 위한 대기 상태에 더 머무름
    - **`CPU 집중 프로세스`** *CPU bound process*
        - CPU 작업이 많은 프로세스
        - 대표적으로 복잡한 수학 연산, 컴파일, 그래픽 처리 작업 등
        - 대기 상태보다는 실행 상태에 더 머무름

> ♻️ ** CPU 버스트와 입출력 버스트**
> 
> - `CPU 버스트(CPU burst)` - CPU를 이용하는 작업
> - `입출력 버스트(I/O burst)` - 입출력장치를 기다리는 작업
> 
> 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행됨
> 
> 입출력 집중 프로세스는 입출력 버스트가 많은 프로세스, CPU 집중 프로세스는 CPU 버스트가 많은 프로세스

- CPU 집중 프로세스와 입출력 집중 프로세스 중 CPU 집중 프로세스가 CPU를 더 많이 사용해야 하므로 더 많은 빈도로 CPU를 사용하는 것이 합리적
- **입출력** 집중 프로세스와 **CPU** 집중 프로세스가 동시에 CPU 자원을 요구할 경우
    
    ![image](https://github.com/user-attachments/assets/fdddb5b1-da18-465a-961c-fc423a2b6531)
    
    - **입출력 집중 프로세스를 먼저 실행**하여 입출력장치를 끊임없이 작동시키고, 해당 프로세스가 입출력 작업을 하며 `대기` 상태로 존재하는 동안
    - **CPU 집중 프로세스**에 CPU를 집중적으로 할당하는 것이 효율적
    - 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있음
    
    ⇒ 일반적으로 입출력 집중 프로세스의 우선순위가 더 높음
    
- 운영체제는 프로세스마다 `**우선순위 *priority***`를 부여함
    - 운영체제는 각 프로세스의 **PCB**에 우선순위를 명시하고, **PCB**에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정
    - → 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행


> 💡 **프로세스의 우선순위 직접 확인하기**
> 
> 우선순위가 높은 대표 프로세스 - 입출력 집중 프로세스, 실시간, 일부 백그라운드 프로세스 등 
> `ps -el` 명령어로 확인

<br>

### 스케줄링 큐

PCB에 우선순위가 적혀있지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 ***일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적***

CPU를 원하는 프로세스들은 한두 개가 아니고, CPU를 요구하는 새로운 프로세스는 언제든 생기기 때문

CPU자원 외에도 메모리, 입출력장치, 보조기억장치 등의 자원을 원하는 프로세스가 있을 때도 매번 PCB를 검사하는 것은 비효율적

따라서 **운영체제**는 프로세스들에게 줄을 서서 기다릴 것을 요구함 → 프로세스의 상태별로 `우선순위`에 따라 **줄** **`스케줄링 큐** *scheduling queue*`  세움

> 엄밀히 큐는 선입선출 FIFO이지만, 스케줄링에서 이야기하는 큐는 선입선출일 필요는 없음
일반적으로는 **우선순위 큐**
> 

![image](https://github.com/user-attachments/assets/8fcaeaa3-231f-4538-9cda-67ce9b3cfec1)


- 운영체제가 관리하는 `대부분의 자원`은 **큐**로 관리됨
- **큐의 종류**
    - **준비 큐** *ready queue*
        - CPU를 이용하고 싶은 프로세스들이 줄을 서는 스케줄링 큐
    - **대기 큐** *waiting queue*
        - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 줄을 서는 스케줄링 큐
        - 특정 입출력장치별로 대기 큐가 존재입출력이 완료되어 완료 인터럽트 발생 시 대기 큐에서 제거되고 준비 큐로 이동
    
    ![image](https://github.com/user-attachments/assets/0130a1c7-c27e-4fc6-8949-411f8ccf0c71)

    
- 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다림 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스부터 먼저 실행
- 우선순위가 낮은 프로세스가 먼저 큐에 삽입되어 줄을 섰다고 할지라도 우선순위가 높은 프로세스는 먼저 처리될 수 있음 → VIP
- 대기 상태도 마찬가지 → 같은 장치를 요구한 프로세스들은 같은 **대기 큐**에서 대기
    - 프린터 사용을 요구하면 프린터 대기 큐에서 입출력 작업이 완료되기를 기다림
    - 입출력이 완료되어 `인터럽트`가 발생하면 운영체제는 **대기 큐**에서 작업이 완료된 PCB를 찾고, 이 PCB를 **준비 상태**로 변경한 뒤 대기 큐에서 제거
    - 해당 PCB는 **준비 큐**로 이동
    
    ![image](https://github.com/user-attachments/assets/3f9c50eb-88f5-47f2-8928-ba2ac63ede21)

    
- 확장된 프로세스 다이어그램
    
    ![image](https://github.com/user-attachments/assets/f9ad8c9d-79f2-4b74-9b9f-044f4b182c56)

<br>

### 선점형과 비선점형 스케줄링

❓ 어떤 프로세스가 CPU를 잘 사용하고 있는데, 다른 급한 프로세스가 CPU를 지금 당장 사용하길 요청한다면?

 1. CPU를 빼앗아 다른 프로세스에게 할당

1. 기존 작업이 끝날 때까지 다른 프로세스를 기다리게 함
- **스케줄링 기법**
    - **선점형 스케줄링** *preemptive scheduling*
        - 선점 - 남보다 앞서서 차지함
        - 프로세스가 시스템 자원을 사용하고 있더라도 운영체제가 **`강제로 빼앗아`** 다른 프로세스에게 할당 가능
        - 어느 하나의 프로세스가 자원 사용을 **`독점할 수 없는` 방식**
        - CPU 사용의 정해진 시간을 모두 소비하여 **타이머 인터럽트**가 발생하면 CPU 자원을 뺏어 다음 프로세스에게 전달하는 것도 여기에 포함
        - **대부분의 운영체제**에서 차용하고 있는 방식
        - 프로세스들에 **`골고루 자원을 배분`**할 수 있다는 장점
        - **문맥 교환** 과정에서의 `오버헤드` 발생
    - **비선점형 스케줄링** *non-preemptive scheduling*
        - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 방식
        - 어느 하나의 프로세스가 자원 사용을 `독점할 수 있는` 방식
        - 문맥 교환 시의 오버헤드는 적지만 모든 프로세스가 자원을 골고루 사용 불가

<br>

## 11-2. CPU 스케줄링 알고리즘

> `선입 선처리 스케줄링`   `최단 작업 우선 스케줄링`   `라운드 로빈 스케줄링`   `우선순위 스케줄링`   `다단계 피드백 큐 스케줄링`
> 

CPU 스케줄링 알고리즘은 다양하고 운영체제마다 다른 알고리즘을 사용함

- **선입 선처리 스케줄링 = FCFS 스케줄링** ***First-Come First-Scheduling***
    - 준비 큐에 삽입된 **`순서대로`** 프로세스를 처리하는 `비선점형` 스케줄링 방식
    - CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링
    - CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스들이 기다리는 시간이 매우 길어질 수 있음
    - **호위 효과** *convoy effect*
        - CPU를 짧게 사용하는 프로세스가 CPU를 오래 사용하는 프로세스를 기다리며 잠깐의 실행을 위해 오래 기다리게 되는 현상
        
        ![image](https://github.com/user-attachments/assets/48eb5e25-f45a-4f57-a6e8-34106b3592eb)

        
- **최단 작업 우선 스케줄링 = SJF 스케줄링** ***Shortest Job First** **Scheduling***
    - 호위 효과를 방지하기 위해 `CPU 사용 시간이 짧은 프로세스`를 먼저 실행하는 `비선점형` 스케줄링 방식
- **라운드 로빈 스케줄링** *round robin scheduling*
    - **선입 선처리 스케줄링**에 **`타임 슬라이스`** *time slice(*프로세스가 CPU를 사용할 수 있도록 정해진 시간) 개념이 더해진 방식
    - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 `선점형` 스케줄링
    - 프로세스가 정해진 시간(타임 슬라이스)만큼만 CPU를 이용하고 아직 프로세스가 완료되지 않았다면 **준비 큐** 맨 뒤에 삽입 (`문맥 교환` 발생)
    
    ![image](https://github.com/user-attachments/assets/e39af6c0-5c23-4767-b6ba-f53495f84829)

    
    - **`타임 슬라이스의 크기`**가 중요
        - 타임 슬라이스가 지나치게 크면 FCFS와 비슷하여 호위 효과의 여지가 있고, 너무 작으면 문맥 교환 오버헤드가 커지는 문제가 생김
- **최소 잔여 시간 우선 스케줄링 = SRT 스케줄링** ***Shortest Remaining Time***
    - 최단 작업 우선 스케줄링(**`SJF`**)에 **`라운드 로빈`** 스케줄링을 합친 방식
    - `선점형` 스케줄링 방식
    - **최소 잔여 시간 우선 스케줄링** 하에서 프로세스들은 정해진 **타임 슬라이스**만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨
    > ### 잔여 시간을 어떻게 알 수 있을까?
    > 1. **정확한 잔여 시간 모름**
    >   운영체제는 **프로세스가 앞으로 얼마나 걸릴지 정확히는 모름**
    > 2. **예측을 사용하거나, 다른 정책을 씀**
    > - 🔹 **SJF / SRT는 이론적 모델로** 활용
    >   → 프로세스 스케줄링 알고리즘 분석, 연구, 성능 평가 등에 쓰임
    > - 🔹 **지수 평균 기반 예측**
    >   → 과거 CPU burst 시간으로 다음 burst 시간 **예측**
    >   → 이 예측값을 사용해서 **SJF / SRT에 근접한 스케줄링** 구현 가능
    >   → 예: UNIX 계열 OS들 일부가 이 방식을 일부 활용
    > - 🔹 **실시간 시스템**에서는 **명시된 실행 시간** 사용
    >   → 프로세스 시작 전에 **최대 실행 시간 (WCET)**을 명시해야 함
    >   → 이 경우, 잔여 시간도 계산 가능
    > - 🔹 **현대 운영체제는 라운드 로빈 + 우선순위 기반** 스케줄링을 많이 씀
    >   → 정확한 예측 어려우니 그냥 시간 쪼개서 빠르게 교체하며 공정성 유지
  
- **우선순위 스케줄링** *priority scheduling*
    - 프로세스들에 우선순위를 부여하고, `가장 우선순위가 높은` 프로세스부터 실행하는 방식
        - 우선순위가 같은 프로세스끼리는 선입 선처리
    - 최단 작업 우선 스케줄링(**SJF**)과 최소 잔여 시간 우선 스케줄링(**SRT**)도 넓게 보면 여기에 포함
    - **문제점**
        - 우선순위가 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고)의 실행이 계속 연기되는 **기아** *starvation* 현상 발생 가능
    - **방지법**
        - 오래 대기한 프로세스의 우선순위를 점차 높이는 **에이징** *aging* 기법
        - 나이 먹듯 대기할 수록 우선순위를 높임
- **다단계 큐 스케줄링** *multilevel queue scheduling*
    - 우선순위별로 `준비 큐를 여러 개` 사용하는 방식
    - **우선순위가 가장 높은 큐에 있는 프로세스**를 먼저 **처리**하고, 비어 있을 경우 **다음 우선순위의 큐** 처리
    - **`프로세스 유형`별**로 **우선순위**를 **구분**하여 실행하기 편리
        - 어떤 큐에는 우선순위가 비교적 높아야 하는 CPU 집중 프로세스, 백그라운드 프로세스가 삽입, 다른 큐에는 우선순위가 비교적 낮아도 상관없는 입출력 집중 프로세스, 사용자와의 상호작용이 잦은 프로세스가 삽입됨
    - 큐별로 타임 슬라이스, 별도의 스케줄링 알고리즘 등을 설정 가능
    - 프로세스들이 큐 사이 이동 불가하므로 **`기아`** 발생 여지가 있음
- **다단계 피드백 큐 스케줄링** *multilevel feedback queue scheduling*
    - 다단계 큐 스케줄링에서 발생할 수 있는 **기아 현상을 방지**하기 위해 발전된 형태
    - 프로세스들이 `큐 사이 이동` 가능
    - 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 실행됨
    - 프로세스가 해당 큐에서 `타임 슬라이스` 동안 실행이 끝나지 않는다면 **다음 우선순위 큐**에 삽입되어 실행되고, 계속해서 다음 큐로 이동하면서 점차 **`우선순위가 낮아짐`**
        - CPU 집중 프로세스들은 CPU를 오래 사용하므로 우선순위가 자연스레 낮아지고,
        CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝남
        
       ![image](https://github.com/user-attachments/assets/13da9417-3af5-476e-8211-ce616e09bd84)

        
    - 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 **점차 높은 우선순위 큐**로 이동시키는 **에이징 기법**을 적용하여 기아 현상을 예방
        
       ![image](https://github.com/user-attachments/assets/8b2b4f05-99db-489d-86bf-c9e73cf4ec4c)

        
    - 구현이 복잡하지만, **가장 일반적인 CPU 스케줄링 알고리즘**
        
        ![image](https://github.com/user-attachments/assets/5d412751-d5ea-4587-a754-bb378e6022e0)

        

![image](https://github.com/user-attachments/assets/636b24cc-5549-4caa-ac07-956fa6e0e8f0)
