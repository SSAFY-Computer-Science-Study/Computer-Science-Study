# 04. CPU의 작동 원리
## 04-1. ALU와 제어장치
> `ALU`   `플래그`   `제어장치`    `제어 신호`
> 

### CPU
![Image](https://github.com/user-attachments/assets/0eafd66d-b443-40c2-b396-43c3a271f2d8)

### ALU
![Image](https://github.com/user-attachments/assets/42e71d6d-d9ce-4161-b054-9ab66657561b)
- **`ALU`가 받아들이는 정보**
    - 계산을 위해서 **피연산자**와 수행할 **연산**이 필요
    - 레지스터를 통해 **피연산자**를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호**를 받아들여 산술연산, 논리 연산 등 다양한 연산을 수행함
- **`ALU`가 내보내는 정보**
    1. **결과값**
        - **연산을 수행한 결과** = 특정 숫자나 문자 or 메모리 주소
        - 이 **결과값**은 메모리에 바로 저장되지 않고 **일시적으로 레지스터에 저장**
            - **Q.** ALU가 연산할 때마다 결과를 메모리에 저장한다면?
            - **A.** CPU가 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 훨씬 느리기 때문에, ALU가 연산할 때마다 결과를 메모리에 저장한다면 CPU는 메모리에 자주 접근하게 되어 프로그램 실행속도를 늦출 수 있음 → 따라서 우선 레지스터에 저장
    2. **플래그** *flag*
        - 연산 결과에 대한 **추가적인 상태 정보**
            ![Image](https://github.com/user-attachments/assets/dd30d833-c85b-414e-996f-93707b6c8ab8)
        - 플래그들은 **플래그 레지스터** *flag register* 에 저장
            ![Image](https://github.com/user-attachments/assets/0dc0c98c-159b-4dcc-8810-4918677a33a3)
            - ALU가 연산을 수행하고 난 후, **플래그 레지스터를 확인**함으로써 CPU는 연산 결과에 대한 중요한 상태 정보를 기억
- ALU 내부에는 여러 계산을 위한 **회로**가 있음
    - 가산기(덧셈), 보수기(뺄셈), 시프터(시프트 연산), 오버플로우 검출기

### 제어장치
- **제어 신호**를 내보내고, **명령어를 해석**하는 부품
    - **제어 신호**
        - 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
- CPU 구성 요소 중 가장 정교하게 설계된 부품으로, 제조사마다 고유의 방식을 사용
![Image](https://github.com/user-attachments/assets/761fc61e-c2b5-4538-bbbe-0ef6b3c6718d)

- **`제어장치`가 받아들이는 정보**
    1. **클럭(신호)** *clock* 
        ![Image](https://github.com/user-attachments/assets/be505ab7-0074-4526-9d04-a40b3a1a872f)
        - 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
        - 클럭 주기에 맞춰 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들임
        - 컴퓨터의 부품들은 클럭에 박자에 맞춰 작동할 뿐, 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있음
    2. 해석해야 할 **명령어**
        - **명령어 레지스터**라는 특별한 레지스터에 저장되어 있는 명령어를 받아와서 해석하고
        **제어 신호**를 발생시켜 컴퓨터 부품들이 수행해야 할 내용을 알려줌
    3. **플래그 레지스터** 속 **플래그 값**
        - 플래그 값을 받아들여 제어 신호를 발생
    4. 시스템 버스, 그중에서 **제어 버스로 전달된 제어 신호**
        - 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생 가능
- **`제어장치`가 내보내는 정보**
    - **CPU 외부**에 전달하는 **제어 신호**
        - 제어 버스로 제어 신호를 내보냄
        - **메모리**에 전달 → 메모리에 저장된 값을 읽거나 새로운 값을 쓸 때
        - **입출력장치**(보조기억장치 포함)에 전달 → 입출력장치의 값을 읽거나 새로운 값을 쓸 때
    - **CPU 내부**에 전달하는 **제어 신호**
        - **ALU**에 전달 → 수행할 연산을 지시할 때
        - **레지스터**에 전달 → 레지스터 간 데이터를 이동하거나 레지스터에 저장된 메모리를 해석할 때

<br>

## 04-2. 레지스터

> `프로그램 카운터`   `명령어 레지스터`    `메모리 주소/버퍼 레지스터`   `범용/플래그 레지스터`   `스택 포인터`   `베이스 레지스터`
> 

프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됨 -> 따라서 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있음  
제조사마다 CPU 구현 방식이 달라 상용화된 CPU 속 레지스터들은 CPU마다 이름, 크기, 종류가 다양함. 많은 CPU가 공통적으로 포함하고 있는 여덟 개의 레지스터를 소개  

1. **프로그램 카운터** *PC; Program Counter*
    - 메모리에서 **읽어 들일** 명령어의 주소를 저장
    - 일부 CPU에서는 **명령어 포인터** *IP; Instruction Pointer* 라고도 불림
    - 기본적으로 저장된 값이 명령어가 차지하고 있는 크기만큼 증가 `PC = PC + 명령어 크기`
    - but,  특정 메모리 주소로 실행 흐름을 이동하는 명령어를 만나면 해당 메모리 주소를 가짐
2. **명령어 레지스터** *IR; Instruction Register*
    - 해석할 명령어 → 방금 메모리에서 **읽어 들인** 명령어를 저장
    - 제어장치에서 이를 받아들이고 해석하여 제어 신호를 내보냄
3. **메모리 주소 레지스터** *MAR; Memory Address Register*
    - CPU가 읽어 들이고자 하는 주소 값을 **주소 버스로 보낼 때** 임시 저장
4. **메모리 버퍼 레지스터** ***MBR**; Memory Buffer Register*
    - **메모리와 주고받을 값**(데이터, 명령어)을 저장 
    → 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 MBR을 거침
    - **데이터 버스**로 주고받을 값이 거침
    - **메모리 데이터 레지스터** *MDR; Memory Data Register* 라고도 불림

-  **동작과정**
    
    ![image](https://github.com/user-attachments/assets/be49ddf2-1402-4d04-9c73-82ab8d9476d8)
    - 카운터에 1000주소 → 메모리 주소 레지스터 1000 → 읽기 신호 → 1000번 읽기
    ![Image](https://github.com/user-attachments/assets/65040091-6261-40b0-8828-b77ba527af35)
    - 데이터버스 통해 MBR에 값 저장 → 카운터 증가 1001 → MBR ⇒ 명령어 레지스터 1001 이동 → 제어장치는 명령어 레지스터의 명령어를 해석하고 제어신호 발생  
    - **프로그램 카운터는 지속적으로 증가**하며 다음 명령어를 읽어 들일 준비를 함  
    - → 따라서 **CPU가 메모리 속 프로그램을 순차적으로 읽고 실행**할 수 있는 것!
> ### ✅ 순차적인 실행 흐름이 끊기는 경우
> 프로그램 카운터가 실행 중인 명령어의 다음 주소가 아니 전혀 다른 값으로 업데이트 되는 경우 프로그램은 순차적으로 실행되지 않음
> **예)** 명령어 중 JUMP, CONDITIONAL JUMP, CALL, RET와 같이 특정 메모리 주소로 실행 흐름을 이동하는 경우 카운터에는 변경된 주소가 저장

5. **범용 레지스터** *general purpose register*
    - 다양하고 일반적인 상황에서 자유롭게 사용 → 데이터와 주소 모두 저장 가능
    - CPU 안에 여러 개의 범용 레지스터가 있고, 현재 대다수 CPU는 모두 가지고 있음
6. **플래그 레지스터** *flag register*
    - ALU 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장
7. **스택 포인터** *stack pointer*
    - **스택 주소 지정 방식**이라는 주소 지정 방식에서 사용
8. **베이스 레지스터** *base register*
    - 베이스 레지스터 주소 지정 방식에서 기준 주소로 사용

### 특정 레지스터를 이용한 주소 지정 방식 - 1. 스택 주소 지정 방식
![Image](https://github.com/user-attachments/assets/f8f6127e-49c1-4501-9425-52cfa90f7129)
- **스택**과 **스택 포인터**를 이용한 주소 지정 방식
    - **스택 포인터** - 스택에 마지막으로 저장한 값의 위치를 저장
- 스택은 메모리를 스택처럼 사용하기 위해 지정되어 있는 **스택 영역**이라는 곳에 존재함

### 특정 레지스터를 이용한 주소 지정 방식 - 2. 변위 주소 지정 방식
![Image](https://github.com/user-attachments/assets/1d8a9f4d-e767-49b6-996f-bf1702ddd5a6)
- *displacement addressing mode*
- 명령어의 **오퍼랜드 필드의 값(변위)**과 **특정 레지스터 값**을 더하여 **유효 주소**를 얻어내는 주소 지정 방식
- 변위 주소 지정 방식을 사용하는 명령어
    ![Image](https://github.com/user-attachments/assets/08988504-efbe-42eb-a819-4f9e0275cd88)
> 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 방법이 나뉨
>

1. **상대 주소 지정 방식** *relative addressing mode*
    ![Image](https://github.com/user-attachments/assets/1eb03ca3-1307-49ec-a3bb-e0e1ec5ada89)
    - 오퍼랜드와 `프로그램 카운터`의 값을 더하여 유효 주소를 얻는 방식
    - 프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있으므로, 오퍼랜드 값과 더하면 CPU는 읽어들일 명령어로부터 `오퍼랜드 값만큼 이동한 번지` 로 접근
    - if문처럼 모든 코드를 실행하는 게 아닌 분기하여 **특정 주소의 코드를 실행**할 때 주로 사용
2. **베이스 레지스터 주소 지정 방식** *base-register addressing mode*
    ![Image](https://github.com/user-attachments/assets/34aaa300-983a-49fd-946c-2cb1ef3accff)
    - 오퍼랜드와 **`베이스 레지스터`**의 값을 더하여 유효 주소를 얻는 방식
    - 베이스 레지스터 속 기준 주소로부터의 오퍼랜드만큼 떨어진 주소

### 대중적 CPU (x86)과 ARM 레지스터
https://github.com/kangtegong/self-learning-cs

<br>

## 04-3. 명령어 사이클과 인터럽트

> `명령어 사이클`   `인터럽트`   `예외`   `하드웨어 인터럽트`    `인터럽트 서비스 루틴`
> 

CPU는 하나의 명령어를 처리하는 정해진 흐름인 **명령어 사이클**에 따라 **명령어를 처리해나가지만, 간혹 이 사이클이 끊어지는 **인터럽트**가 발생함

### 명령어 사이클

> instruction cycle - 프로그램 속 각각의 명령어는 일정한 주기, 즉 명령어 사이클이 반복되며 실행
> 

![Image](https://github.com/user-attachments/assets/b319a258-b250-469d-991c-062bd50725bf)

- 명령어 사이클의 단계
    1. **인출 사이클** *fetch cycle*
        - 메모리에 있는 명령어를 CPU로 가지고 오는 단계
        - 프로그램 카운터의 값을 메모리 주소 레지스터에 복사한 뒤 제어 버스와 주소 버스를 통해 해당 메모리의 값을 요청하고,데이터 버스를 통해 메모리 버퍼 레지스터에 받아온 값을 명령어 레지스터에 복사함
    2. **실행 사이클** *execution cycle*
        - CPU로 가져온 명령어를 실행하는 단계
        - 제어장치가 명령어 레지스터에 담긴 값을 해석하고 제어 신호를 발생시킴
    수많은 명령어는 인출과 실행 사이클을 반복하며 실행
    3. **간접 사이클** *indirect cycle*
        - 명령어 실행을 위해 메모리 접근이 한 번 더 필요한 경우 실행 사이클 이전에 필요한 값을 가져오는 단계
        - 예) 간접 주소 방식에서 명령어를 실행하기 위해 메모리에 한 번 더 접근해야 함
    4. **인터럽트 사이클** *interrupt cycle*
        - 인터럽트가 발생한 경우에만 수행하며 이를 처리하는 단계

### 인터럽트

> CPU가 수행 중인 정상적인 작업을 방해하여 중단하게 하는 신호
> 
- 인터럽트의 종류
    - **동기 인터럽트** *synchronous interrupts*
        - `CPU`에 의해 발생하는 인터럽트
        - CPU가 명령어를 수행하다가 프로그래밍상 오류와 같은 예상치 못한 상황에 마주쳤을 때 발생하는 인터럽트
        - → **`예외`** *exception* 라고도 불림
        - 프로그래밍에서 "예외 처리"를 한다고 할 때 바로 그 예외 →이것을 적절하게 처리한 후 본래 하던 작업으로 되돌아와 실행을 재개
- **비동기 인터럽트** *asynchronous interrupts*
    - 주로 `입출력장치`에 의해 발생하는 인터럽트
        - 예) 키보드 입력, 프린터 출력
    - 일반적으로 말하는 인터럽트로 **`하드웨어 인터럽트`** *hardware interrupt* 라고도 함

### 하드웨어 인터럽트 (비동기 인터럽트)

> CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 사용

**예)** CPU보다 속도가 느린 입출력 작업을 기다릴 때 지속적으로 완료 여부를 물어보지 않고,
     다른 작업을 처리하다가 입출력 작업 완료 인터럽트를 받으면 필요한 입출력 작업을 수행
> 
- 하드웨어 인터럽트 처리 순서
    1. 입출력장치는 CPU에 **`인터럽트 요청 신호`** 전송
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
    3. CPU는 인터럽트 요청을 확인하고 **`인터럽트 플래그`**를 통해 현재 인터럽트를 받아들일 수 있는지 확인
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
    5. CPU는 **`인터럽트 벡터`**를 참조하여 **`인터럽트 서비스 루틴`** 실행
    6. 인터럽트 서비스 루틴이 끝나면 4에서 백업한 작업을 복구하여 실행
- 주요 개념
    - **인터럽트 요청 신호**
        - CPU에 인터럽트 가능 여부를 확인하기 위한 신호
    - **인터럽트 플래그** *interrupt flag*
        - CPU가 하드웨어 인터럽트를 받아들일지 무시할지 결정하는 플래그
        - CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 **인터럽트 플래그**가 활성화되어야 함
        - CPU가 중요한 작업을 처리해야 하거나 어떠한 방해도 받지 않아야 할 때 인터럽트 플래그는 불가능으로 설정 → 이 경우 CPU는 인터럽트 요청 무시
        - but, 어떤 인터럽트는 **이 플래그가 불가능으로 설정되어 있어도 무조건 실행**
        → 가장 우선순위가 높은 인터럽트
        예) 정전이나 하드웨어 고장으로 인한 인터럽트
            - 막을 수 있는 인터럽트 *maskable interrupt*
            - 막을 수 없는 인터럽트 *non maskable interrupt*
    - **인터럽트 서비스 루틴** *ISR; Interrupt Service Routine*
        
        ![Image](https://github.com/user-attachments/assets/8676da14-668a-4adb-8759-c7719cd34ffa)
        
        - 인터럽트를 처리하기 위한 프로그램 ⇒ **인터럽트 핸들러** *interrupt handler* 라고도 함
        - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보가 담김
        - CPU가 인터럽트 요청을 받아들이기로 했다면 ISR을 실행함
        - CPU가 인터럽트를 처리한다 = ISR을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다
    - **인터럽트 벡터** *interrupt vector*
        
        ![Image](https://github.com/user-attachments/assets/a3b7972f-f805-4cbc-afa6-e26f7cf629b6)
        
        - 특정 인터럽트 발생 시 실행해야 할 인터럽트 서비스 루틴을 식별하기 위한 정보로 ISR 시작주소를 알 수 있음
        - 인터럽트 요청 신호를 보내는 장치에서 데이터 버스를 통해 인터럽트 벡터가 CPU로 전달
        - 인터럽트 역시 명령어로 이루어진 프로그램으로 PC와 레지스터를 사용
        - → 따라서 기존에 작업하던 PC와 레지스터값 = ISR을 실행하고 돌아와서 재개하기 위해 필요한 값은 스택 영역에 백업
        
        ![Image](https://github.com/user-attachments/assets/b5fffe2f-ceea-4fd8-9abc-335498f0434d)
        
    
    ### 비동기 인터럽트(예외)의 종류
    

    
    예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한 후 다시 본래하던 작업으로 돌아와 실행을 재개함
    
    - **폴트** *fault*
        - 예외 처리 직후 예외가 발생한 명령어부터 실행 재개
        - 인터럽트를 발생시킨 원인을 해결한 뒤 해당 명령어를 다시 실행
    - **트랩** *trap*
        - 예외 처리 직후 예외가 발생한 명령어 다음 명령어부터 실행 재개
        - 트랩 용도
            1. **예외 처리 (Exception Handling)**:
                - 트랩은 예외가 발생한 명령어를 `무효화`하고, 예외가 발생한 지점 바로 **다음 명령어부터 실행을 계속**
            2. **디버깅 (Debugging)**:
                - 디버깅 중에는 프로그램의 실행을 특정 지점에서 **중단**하고 싶을 때 트랩을 사용
                - 디버거가 제어권을 잡고 프로그램을 멈추게 하고, 프로그래머는 프로그램이 멈춘 지점에서 필요한 분석을 진행
    - **중단** *abort*
        - 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류 발견했을 때 발생
        - 본래 하던 작업으로 돌아오지 않고 중단
    - **`09장` 소프트웨어 인터럽트** *software interrupt*
        - 시스템 호출이 발생했을 때 발생
