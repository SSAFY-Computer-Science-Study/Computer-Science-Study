# 13. 교착 상태

## 13-1. 교착 상태란

> `교착 상태`   `식사하는 철학자 문제`   `자원 할당 그래프`   `교착 상태 발생 조건`
> 

프로세스를 실행하기 위해서는 자원이 필요한데, 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다린다면 그 어떤 프로세스도 더 이상 진행할 수 없는 **교착 상태**가 발생

### 식사하는 철학자 문제

- dining philosophers problem
- 교착 상태를 설명하기 위한 가상의 문제 시나리오

![image](https://github.com/user-attachments/assets/61e09cc7-cf39-4cf4-ad89-a6c3ca53c93f)
![image](https://github.com/user-attachments/assets/debac956-2cc3-4d0b-a0ef-dd642f99247a)

- 한두 명의 철학자가 식사할 때는 문제가 없음
- 모든 철학자가 동시에 포크를 집어 식사를 하면 어떠한 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생함 (모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없기 때문)
- 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다림
- **프로세스 관점**
    - 철학자 = 프로세스 or 스레드
    - 포크 = 자원
        - 한 번에 하나의 프로세스 혹은 스레드만 접근 가능하므로 **임계 구역**
    - 생각하는 행위 = 자원을 기다리는 것

> **교착 상태** *deadlock*
> 일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상
> 
> 둘 이상의 프로세스가 서로가 독점하고 있는 자원을 기다릴 때 발생
> 
> ![image](https://github.com/user-attachments/assets/22e34e94-bc44-4987-801d-e8e99fed570b)
> 
- **예)** 뮤텍스 락에서 발생하는 교착 상태
    - 프로세스 A는 임계 구역 진입 전  lock1을 잠그고, 프로세스 B는 임계 구역 진입 전 lock2를 잠근 상황
    ![image](https://github.com/user-attachments/assets/643d4133-dcc5-4de9-9c3f-4f938974ea01)
    
    - 프로세스 A는 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false가 되길 기다린다면 교착 상태가 발생

- **교착 상태 해결을 위해서**
    1. 교착 상태가 발생했을 때의 상황을 정확히 표현
    2. 교착 상태가 일어나는 근본적 이유에 대해 알아야 함

### 자원 할당 그래프

교착 상태는 **자원 할당 그래프** *resource-allocation graph* 를 통해 단순하게 표현할 수 있다.

어떤 **프로세스**가 **어떤 자원을 사용**하고 있으며 어떤 **자원을 기다리고 있는지** 나타낸다.

1. **프로세스**는 `원`으로, **자원의 종류**은 `사각형`으로 표현
2. 사용할 수 있는 **자원의 개수**는 자원 사각형 내 `점`으로 표현
    - 같은 자원이라 할지라도 사용 가능한 자원의 개수는 여러 개 있을 수 있음
    - **종류** → `사각형`, **개수** → `점`
3. 프로세스가 어떤 자원을 할당 받아 **사용 중**이라면 **`자원→프로세스 방향**의 화살표`로 표현
4. 프로세스가 **기다리는** 자원은 **`프로세스→자원** 방향의 화살표`로 표현
- **예)** 현재 사용가능한 SSD 자원 3개, CPU 자원 2개, 프린터 1개
    - 프로세스 A는 SSD를 할당받아 사용 중
    - 프로세스 B, C는 CPU를 할당받아 사용 중
    - 프로세스 D는 프린터를 할당받아 사용 중
    - 프로세스 F는 CPU를 기다리고, 프로세스 E는 프린터를 기다림
    
    ![image](https://github.com/user-attachments/assets/7ebd29bb-8c2e-4a5b-9151-4fa9d6d7b2d8)

    
- **예) 식사하는 철학자**   
    ![image](https://github.com/user-attachments/assets/e0986c5c-6181-45ef-ad34-8a45607313d0)
    
- 자원 할당 그래프가 **`원` → 교착 상태가 발생할 ‘수’ 있음**

### ⭐ 교착 상태 발생 조건

교착 상태가 발생하는 조건에는 **네 가지**가 있으며

**그 중 하나라도 만족하지 않으면 발생하지 않는다.**

- **상호 배제** *mutual exclusion*
    - 한 프로세스가 **사용 중인** 자원을 다른 프로세스가 **사용할 수 없는** 상황
    - **예)** 하나의 포크를 여러 명이 동시에 사용할 수 있다면? 발생 X
- **점유와 대기** *hold and wait*
    - 자원을 **할당받은 상태**에서 다른 자원을 할당받기를 기다리는 상황
    - **예)** 왼쪽 포크를 들고 다른 철학자의 포크를 기다림 → 발생 O
- **비선점** *nonpreemptive*
    - 다른 프로세스의 자원을 강제로 빼앗지 못하고 **작업이 끝나길 기다리는** 상황
    - 예) 포크를 빼앗을 수 있다면? → 발생 X
- **원형 대기** *circular wait*
    - 서로가 서로의 자원을 기다리며 **원의 형태**로 자원을 대기하는 상황

> 💡 자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 ‘수’ 있음. 자원 할당 그래프가 원의 형태를 띄지 않는다면 교착 상태는 발생하지 않으나, 원의 형태라고 해서 반드시 교착 상태가 발생하는 것은 아니다!
> 


<br>

## 13-2. 교착 상태 해결 기법

> `교착 상태 예방`   `교착 상태 회피`   `교착 상태 검출 후 회복`
> 

운영체제가 교착 상태를 해결하는 방법에는 **세** **가지**가 있다.

운영체제는 애초에 교착 상태가 일어나지 않도록 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착 상태를 **`예방`**할 수 있고, 교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식으로 **`회피`**할 수도 있다. 자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 **`회복`**하는 방법을 취할 수도 있다.

### 교착 상태 예방

> 교착 상태 발생 조건 네 가지 중 하나를 충족하지 못하게 한다
> 
- **상호 배제** 제거
    - 모든 자원을 공유 가능하게 만든다
    - 현실 사용에 무리가 있다
- **점유와 대기** 제거
    - 특정 프로세스에 필요한 자원을 한 번에 모두 할당하거나 아무것도 할당하지 않는다
    - 한 프로세스에 필요한 자원을 몰아주는 것의 반복으로 **자원의 활용률이 낮아진다**
        - 당장 자원이 필요해도 기다릴 수밖에 없는 프로세스와 사용되지 않으면서 오랫동안 자원을 할당되는 자원을 다수 양산함
    - **자원을 많이 사용하는 프로세스**가 불리함
        - 자원을 적게 사용하는 프로세스에 비해 **동시에 자원을 사용할 타이밍**을 확보하기 어려워 무한정 기다리는 **기아**가 발생할 우려가 있음
- **비선점** 제거
    - 자원을 이용 중인 프로세스로부터 해당 자원을 **뺏을 수 있다**
    - CPU 등 **선점**하여 **사용**할 수 있는 일부 자원에 대해서 **효과적**
    - 프린터와 같은 자원의 경우 비선점을 제거하기 어려움(한 번에 하나의 프로세스만 이용 가능)
        - **범용성이 떨어짐**
- **원형 대기** 제거
    - 모든 자원에 번호를 붙이고 **오름차순으로 자원을 할당**한다
    - 모든 자원에 번호를 붙이는 작업은 간단한 일이 아니며 각 자원에 어떤 번호를 붙이는지에 따라 **특정 자원의 활용률이 떨어질 수 있다**

> 예방 방식은 교착 상태가 발생하지 않음을 보장할 수는 있지만 여러 부작용이 따른다
> 

### 교착 상태 회피

> **교착 상태가 발생하지 않을 정도로**만 조심 조심 자원을 **할당**하는 방식
> 
> 
> 프로세스에 배분할 수 있는 **자원의 양을 고려**하여 교착 상태가 발생하지 않을 정도의 양만큼만 자원 분배
> 
- 교착 상태를 **한정된 자원**에 대한 **무분별한 할당**으로 인한 문제로 간주
- **용어 정리**
    - **안전 상태** *safe state*
        - 교착 상태 발생 없이 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태
        - **안전 순서열**대로 프로세스들에 **자원 배분**하여 교착상태가 발생하지 않는 상태
        - **안전 순서열** *safe sequence*
            - 교착 상태 없이 **안전**하게 프로세스들에 **자원을 할당할 수 있는 순서**
            - 예) 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제 자원을 요청한 상태에서 교착상태가 발생하지 않는 자원 할당 순서 = 안전 순서열 = 웹 브라우저 → 메모장 → 게임
        - 안전 순서열이 존재!
    - **불안전 상태** *unsafe state*
        - 교착 상태가 발생할 수도 있는 상태
        - 안전 순서열이 존재 X
- **예)** 현재 컴퓨터 시스템에 총 12개의 자원이 있고, 프로세스 P1, P2, P3가 실행 중이며, 각각 5개, 2개, 2개의 자원을 할당 받아 사용 중
    - 운영체제가 프로세스에게 배분할 수 있는 자원은 12 - (5 + 2 + 2) = 3개 남음
    - P1, P2, P3가 각각 최대 10개, 4개, 9개의 자원을 요구할 수 있다고 가정
    
    > 프로세스와 스레드는 자원을 사용하기 위해 **(1)** 우선 자원을 운영체제에게 **요청**하고, **(2)** 운영체제로부터 자원을 **할당받아 사용**하고 **(3)** 자원의 사용이 끝났다면 자원을 **반환**
    > 
    - 현재 상태
        
        ![image](https://github.com/user-attachments/assets/91f4f9ad-e8a4-4af2-b906-231c5f9b7eaa)
        
        - **안전 상태**
        - 안전 순서열 `P2 → P1 → P3`
    - 프로세스 P1, P2, P3가 모두 **최대로 자원**을 요구한 상황 **(5개, 2개, 7개) = (요구량 - 현재 사용량)**
        1. `P2`는 이미 자원 2개를 가지고 있으므로 남은 자원에서 2개를 배분
            
            ![image](https://github.com/user-attachments/assets/926165ac-19a2-4366-9cf1-3d6d1872b717)

            
        2. 요구한 **4개**의 자원을 할당받아 `P2`는 작업을 끝내고 자원을 반환
            
            ![image](https://github.com/user-attachments/assets/4c39dc6b-33f9-4aac-9d93-997d0df459bd)

            
        3. `P1`에 남은 자원 **5개** 할당 → `P1` 작업 종료 후 자원 반환
            
            ![image](https://github.com/user-attachments/assets/ae743942-d5a4-434b-ba60-4a7b6efb677d)

            
        4. `P3`에 할당
            
            ![image](https://github.com/user-attachments/assets/e7ab67b2-7fae-4ee3-afb2-464750533782)

            
    - `P2 → P1 → P3`  → 교착 상태 X
- **예)** 운영체제가 `P3`에게 먼저 선뜻 자원을 **1개** 내주는 상황
    
    ![image](https://github.com/user-attachments/assets/34df41f3-2917-41e5-a767-6224d748b03c)

    
    - 불완전 상태 → 교착 상태가 발생할 위험이 있음
    - P1, P2, P3가 최대로 자원을 요구한 **최악의 상황 (5개, 2개, 6개)**
        
        ![image](https://github.com/user-attachments/assets/040ef939-e19c-4d10-baf8-e2a4a1ac2a92)

        
        - `P2`에게 **2개** 배분하여 `P2`를 종료하고 반환 받은 **2개**를 합치면
        남은 자원은 **4개**이므로 `P1`, `P3` 요구를 들어줄 수 없음
        - `P1`과 `P3`를 서로가 보유하고 있는 자원만을 바라보며 무한정 기다림
        - **교착상태**가 발생

> 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 **안전 상태**에서 **안전 상태**로 움직이는 경우에만 자원을 할당하면 됨 → **안전 상태를 유지하도록** 자원을 할당하는 방식
> 

### 교착 상태 검출 후 회복

> 교착 상태 발생을 인정하고 **사후에 조치**하는 방식
운영체제는 프로세스들이 자원을 요구할 때마다 **그때그때 모두 할당**하며, 교착 상태 발생 여부를 주기적으로 **검사**함 → 교착 상태가 검출되면 **회복**
> 
- **선점을 통한 회복**
    - 교착 상태가 회복될 때까지
        - **한 프로세스씩 자원 몰아주기**
        - 다른 프로세스로부터 자원을 강제로 **빼앗아 한 프로세스에 할당**
- **프로세스 강제 종료를 통한 회복**
    - 가장 단순하면서 확실한 방식
    - 교착 상태에 놓인 프로세스를 모두 **강제 종료**하거나 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료
    - 모두 강제 종료 → (많은 프로세스의 작업 내역 상실)
    - 하나씩 종료 → (교착 상태 제거 여부 확인의 오버헤드 발생)

> ### 💡 타조 알고리즘 ostrich algorithm
> 
> 교착 상태를 아예 **무시**하는 방법도 있음 → 드물게 발생하는 잠재적 문제를 **무시**로 대처하는 방식
