# 02. 데이터
## 02-1. 0과 1로 숫자를 표현하는 방법

> 비트 바이트 이진법 2의 보수 십육진법
> 

### 정보 단위

- **비트** *bit*
    - 컴퓨터가 이해하는 가장 작은 정보 단위로 0 또는 1의 두 가지 정보 표현
    - *n* 비트는 2^*n* 가지 상태 표현 가능
- **바이트** *byte*
    - 8개의 비트를 묶은 단위로 256(2^8)가지 상태 표현 가능.
    
    ![Image](https://github.com/user-attachments/assets/5af83e64-9a7f-4e3b-bf05-36e380c836d8)
    

> 1000개가 아닌 2^10=1024개 단위로 표현한 것은 KiB, MiB, GiB, TiB, ...라고 한다.
> 

```
✅ KiB 키비바이트 (Kibibyte, KiB) = 킬로 이진 바이트(Kilo binary byte)

- 1 KiB = 2^10 byte = 1,024 byte
- 1 KB = 10^3 byte = 1000 byte
- **하드 드라이브**가 **기가 바이트**로 용량이 커져서 대중화되는 동시에 1,000 과 1,024의 용량의 차이를 명확히 하기 위해 등장

```

```
💡 워드 word

- CPU가 한 번에 처리할 수 있는 데이터의 크기, 정보 단위
    - CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트
- **하프 워드** *half word* - 워드의 절반 크기, **풀 워드** *full word* - 1배, **더블 워드** *double word* - 2배
- 워드 크기가 큰 CPU는 한 번에 처리할 수 있는 데이터가 많음
- 현대 컴퓨터의 워드 크기 대부분 32비트 또는 64비트
```

### 이진법

- **이진법** *binary*
    - 0과 1만으로 모든 숫자를 표현하는 방법 → **이진수**
    - 0~9를 이용하여 9를 넘어가면 자리 올림을 하는 십진법처럼
    0~1을 이용하여 1을 넘어가면 자리 올림을 하는 방식.
    - 표기법
        - 1000(2)
        - 0b1000

### 이진수의 음의 표현

- **2의 보수** *two's complement*
    
    ![Image](https://github.com/user-attachments/assets/a0107843-f497-4628-94e0-8786420dc2fc)
    
    - 0과 1만으로 음수를 표현하는 방법
    - 사전적 의미는 ‘어떤 수를 그보다 큰 2^*n*에서 뺀 값’
        - 11의 보수는 2^2(100) - 11 = 01
    - 계산법
        - 모든 0과 1을 뒤집고 거기에 1을 더함
    - 음수의 음수 = 원래 수
        - 보수의 보수 = 원래 수
        - 1011의 보수 = 0101 → 0101의 보수 = 1011
    - `04장` **플래그** *flag*
        - 컴퓨터 내부에서 이진수를 다룰 때 이 수가 양수인지 음수인지 구분하기 위해 사용
        - 나타내는 **플래그**를 사용하곤 한다.
        - 0101 → 플래그에 따라 5 또는 -11로 해석

```
💡2의 보수 표현의 한계

이진수의 음수를 표현하기 위해 2의 보수를 취하는 방식은 가장 널리 사용되지만, **완벽하지는 않다**.
0 이나 2 ^n 형태의 이진수의 2의 보수를 취하면 원하는 음수 값을 얻을 수 없다.

- 0 → 1111 + 1 → 10000 (자리 올림이 됨)
- 1000 → 0111 + 1 → 1000 (자기 자신이 됨)

n비트로는 -2^n과 2^n이라는 수를 동시에 표현할 수 없음

```

### 십육진법

데이터 표현 시 이진법만으로 표현할 경우 너무 길어짐 → 4자리씩 묶어서 표현

0~15를 이용하여 16을 넘어가면 자리 올림을 하는 방식으로, 10~15의 값은 A~F로 표기한다.

- 표기법
    - dd48(16)
    - 0xdd48
- **왜 굳이 16진수를 사용할까?**
    - **이진수와의 변환이 쉽기 때문**

### 십육진수를 이진수로 변환하기

![Image](https://github.com/user-attachments/assets/20fbf91d-2242-46ff-b3b4-88e2ab3c401d)

### 이진수를 십육진수로 변환하기

![Image](https://github.com/user-attachments/assets/1e6e5c5d-f7f3-430d-8d3c-f09a63629499)

## 02-2. 0과 1로 문자를 표현하는 방법

> `문자 집합`  `아스키 코드` `EUC-KR` `유니코드`
> 

### 문자 집합과 인코딩

- **문자 집합** *character set*
    - 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
    - 이것에 속해 있는 문자만 이해할 수 있고 그 외에는 이해할 수 없음
- **문자 인코딩** *character encoding*
    - 문자 집합에 속한 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정
    - 같은 문자 집합에 대해서도 다양한 인코딩 방법이 있을 수 있음
- **문자 디코딩** *character decoding*
    - 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정

### 아스키 코드

- *ASCII; American Standard Code for Information Interchange*
    - 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함하는 초창기 문자 집합
    - **아스키 문자** | 7비트로 표현되는 128개의 값이 문자와 일대일 대응
        - 실제 하나의 아스키 문자를 나타내기 위해 8비트(1바이트) 사용 → 1비트는 **패리티 비트***(parity bit)*로 오류 검출을 위해 사용
    - 아스키 문자는 **아스키 코드**로 인코딩 .
        - `‘A’ - 65`, `‘a’ - 97`
    - 한글을 포함하여 다양한 문자를 표현하지 못하는 단점
        
        → 1비트 추가한 **확장 아스키**가 등장했지만 역부족
        

### **EUC-KR**

- 한글을 인코딩할 수 있는 방식 ⇒ 완성형 인코딩
- **한글 인코딩 방식**
    - **완성형 인코딩**
        - 초성, 중성, 종성의 조합으로 완성된 글자에 고유한 코드를 부여    
        예) ‘가’-1
    - **조합형 인코딩**
        - 초성, 중성, 종성에 각각 비트열을 할당하여 비트열의 조합으로 글자 코드를 만듦 
        예) ㄱ(0010) ㅏ(0011) ⇒ 가 (0010 0011)
- 한글 한 글자에 2바이트 코드 → 16bit → 4자리 16진수
- 총 2350개의 한글 단어 표현 → 모든 한글을 표현할 수 없음

### 유니코드와 UTF-8

- **유니코드** *unicode*
    - 모든 나라 언어의 문자 집합과 인코딩 방식을 통일하여 인코딩의 수고로움을 덜기 위한 방식현대 문자 표현에 가장 많이 사용
    - 한글 표현에는 EUC-KR과 마찬가지로 완성형 인코딩 방식 사용.
- **UTF-8**
    - 유니코드 인코딩 방식은 UTF-*n*로 표기되는데, 그 중 가장 대중적인 방식
    - 유니코드 문자에 부여된 값의 범위에 따라 1바이트~4바이트로 인코딩
    - 한글의 경우 3바이트로 표현
