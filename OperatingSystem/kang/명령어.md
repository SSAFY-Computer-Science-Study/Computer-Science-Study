# 03. 명령어
## 03-1. 소스 코드와 명령어

> `고급 언어`   `저급 언어`   `기계어`   `어셈블리어`   `컴파일 언어`   `인터프리터 언어`
> 

프로그래밍 언어로 작성한 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환

### 고급 언어와 저급 언어

- **고급 언어** *high-level programming language*
    - 사람이 이해하고 작성하기 쉽게 만들어진 언어
    - 대부분의 프로그래밍 언어를 포함
    - 저급 언어로 변환하여 명령어 형태가 되어야 실행 가능
    - **예) 컴파일 언어, 인터프리터 언어**
- **저급 언어** *low-level programming language*
    - 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - **명령어**로 이루어짐
    - **기계어** *machine code*
        - 0과 1의 명령어 비트로 이루어진 언어 → 이진수 혹은 십육진수로 표기
    - **어셈블리어** *assembly language*
        ![Image](https://github.com/user-attachments/assets/892993d6-f596-4fd8-9ce4-6c89f2901ba6)
        - 기계어를 읽기 편한 형태로 번역한 언어
        - 기계어에 비해 읽기 수월하지만 복잡한 프로그램 만들기는 난해 (하드웨어쪽)

### 컴파일 언어와 인터프리터 언어

### **- 컴파일 언어**

- **컴파일 방식**으로 작동하는 프로그래밍 언어      **예) C**
- 컴파일러에 의해 **소스 코드 전체가 저급 언어로 변환**되어 실행 → **컴파일***compile*
- **컴파일러** *compiler*
    - 개발자가 작성한 소스 코드 전체를 쭉 훑어보며 문법적인 오류, 실행 가능 여부, 불필요한 코드 존재 여부 등 확인하며 저급 언어로 변환
    소스 코드 내에서 오류를 하나라도 발견하면 컴파일 실패
    - **목적 코드** *object code*
        - 컴파일러를 통해 저급 언어로 변환된 코드
        - 목적 코드에 외부 기능을 연결 짓는 링킹 과정을 거치면 실행 파일

### **- 인터프리터 언어**

- **인터프리트 방식**으로 작동하는 프로그래밍 언어
- 인터프리터에 의해 **소스 코드가 한 줄씩 실행**되는 고급 언어
- **인터프리터** *interpreter*
    - 소스 코드를 한 줄씩 저급 언어로 변환하여 실행하는 도구
    - 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요 없고
    오류가 발생하기 직전 줄까지는 수행 가능
    - but, **컴파일 언어보다 느림** 
    → 목적 코드는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄 한 줄씩 저급 언어로 해석하며 실행해야하기 때문


> ### ✅ **컴파일 언어와 인터프리터 언어, 칼로 자르듯이 구분될까?**
>
> C, C++은 명확히 컴파일 언어  
> but, 현대 많은 언어는 경계가 모호함  
> 인터프리터 언어로 알려진 Python도 컴파일을 하지 않는 것은 아니며, **Java**에 경우 저급언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행 `🔥추가개념`
>  
> → 즉, **하나의 프로그래밍 언어가 반드시 둘 중 하나의 방식만으로 작동한다** ❌  
> ⇒ 고급 언어가 저급 언어로 변환되는 방법에는 컴파일, 인터프리터 방식이 있다 ⭕  

### 목적 파일 vs 실행 파일

- **목적 파일**
    - 목적 코드로 이루어진 파일
    - 저급 언어
    - 목적 코드가 실행 파일이 되기 위해서는 **링킹***linking*을 거쳐야 함`🔥추가개념`
- **실행 파일**
    - 실행 코드로 이루어진 파일     **예) .exe**

<br>

## 03-2. 명령어의 구조

> `명령어`   `연산 코드`   `오퍼랜드`   `주소 지정 방식`
> 

### 연산 코드와 오퍼랜드

명령어는 `무엇을 대상(operand)으로, 어떤 작동(operation)을 수행하라`는 구조
![Image](https://github.com/user-attachments/assets/e4330176-0827-405c-84e4-da680a77711e)

- **오퍼랜드** *operand*
    - 연산에 사용할 **데이터** or 연산에 사용할 데이터가 저장된 **위치**
    - **오퍼랜드 필드(= 주소 필드)**
        - 숫자와 문자와 같은 데이터 or 레지스터 주소
        - 많은 경우 데이터를 직접 담기보다는 **데이터의 위치** → 메모리 주소나 레지스터 이름이 담김 ⇒ **주소 필드**라고도 함
    - ***n-*주소 명령어** (n ≥ 0) ****
        - 오퍼랜드가 n개 있는 명령어
- **연산 코드** *operation code*
    - 명령어가 수행할 **연산**
    - 유형 4가지
        - 명령어는 CPU마다 다르기 때문에 대부분의 CPU가 이해하는 연산 코드를 소개
        1. **데이터 전송**
            
           ![Image](https://github.com/user-attachments/assets/f18bbc9e-1d15-4c5b-be30-59ede8f10884)
            
        2. **산술/논리 연산**
            
            ![Image](https://github.com/user-attachments/assets/3d9ead8a-8ab5-4ed2-a921-f452582080fd)
            
        3. **제어 흐름 변경** (함수)
            
            ![Image](https://github.com/user-attachments/assets/4fb02564-7464-40ff-a3e6-9a941c5e79c3)
            
        4. **입출력 제어**
            
            ![Image](https://github.com/user-attachments/assets/9a4378eb-03a1-474a-a8bc-370f38bde5ca)
            

### 주소 지정 방식

> ### ❓. 왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담을까? **데이터를 직접 담으면** 안될까?  
> A. **명령어의 길이** 때문!  
> 하나의 명령어는 `n`비트로 구성
> 그중 연산 코드 필드 `m` 비트라면 1-주소 명령어라할지라도 오퍼랜드 필드의 길이는 `n - m`비트로 오퍼랜드가 많아진다면 길이는 더 줄어듬  
> 예) 명령어 크기 16비트, 연산 코드 4비트인 2-주소 명령어  
> → 오퍼랜드 필드는 각각 6비트로 **2^6 종류의 정보만 담을 수 있음**
> 
> 따라서 오퍼랜드 필드에 **주소를 담는다면, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 데이터의 크기로 커진다**!  

- **유효 주소** *effective address*
    - 연산의 대상이 되는 데이터가 저장된 위치
- **주소 지정 방식** *addressing mode*
    - **연산에 사용할 데이터의 위치(=유효 주소)**를 찾는 방법

### `04장`주소 지정 방식의 종류

- **즉시 주소 지정 방식** *immediate addressing mode*
    
    ![Image](https://github.com/user-attachments/assets/f4e85a89-6ece-4849-a19c-9e7a02c5f214)
    
    - 연산에 사용할 **데이터**를 오퍼랜드 필드에 직접 **명시**하는 방식
    - 가장 간단하고 데이터를 저장된 위치로부터 찾는 과정이 없어 빠르지만, 데이터의 크기가 제한적
- **직접 주소 지정 방식** *direct addressing mode*
    
    ![Image](https://github.com/user-attachments/assets/c3596c39-d565-4dfa-a626-c0e5ae511a99)
    
    - 오퍼랜드 필드에 **유효 주소(메모리 주소)를 직접적으로 명시**하는 방식
    - 즉시 주소 지정 방식보다 데이터 크기 커짐
    - 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 있음
- **간접 주소 지정 방식** *indirect addressing mode*
    
    ![Image](https://github.com/user-attachments/assets/68e0409a-f741-4009-b361-a12e1c412721)
    
    - 데이터가 **메모리**에 있을 때, 오퍼랜드 필드에 **유효 주소의 주소를 명시**하는 방식
    - 데이터와 유효 주소 모두 메모리에 존재
    - 직접 주소 지정 방식보다 표현할 수 있는 유효 주소 범위가 커짐
    - but, 두 번의 메모리 접근이 필요하여 상대적으로 느림
- **레지스터 주소 지정 방식** *register addressing mode*
    
    ![Image](https://github.com/user-attachments/assets/b541b99c-d094-403c-99fc-92aa61c0edcc)
    
    - 데이터가 **레지스터**에 저장된 경우
    - 직접 주소 지정 방식과 비슷하게 오퍼랜드 필드에 **데이터를 저장한 유효주소(레지스터 이름)를 직접적으로 명시**하는 방식
    - CPU 내부 레지스터에 접근하므로 메모리 접근에 접근하는 직접 주소 방식보다 빠름
    - but, 같은 문제 공유 → 표현할 수 있는 레지스터 크기에 제한이 있음
- **레지스터 간접 주소 지정 방식** *register indirect addressing mode*
    
    ![Image](https://github.com/user-attachments/assets/7a03fe78-d94e-47de-9cc6-ab4477d3ff13)
    
    - 연산에 사용할 **데이터를 메모리**에 저장하고, 그 **주소(유효 주소)를 저장한 레지터**를 오퍼랜드 필드에 명시하는 방식
    - 간접 주소 지정 방식과 비슷하지만, 메모리 접근을 1번 밖에 안하므로 더 빠름 (메모리 접근 속도보다 레지스터 접근 속도가 더 빠름)
    - 데이터는 메모리에, 유효 주소는 레지스터에 존재
- 🔥 **총 정리**
    
    
    | 주소 지정 방식 | 레지스터 사용 | 메모리 접근 |
    | --- | --- | --- |
    | **즉시(Immediate)** | ✅  | ❌  |
    | **직접(Direct)** | ❌  | ✅  |
    | **간접(Indirect)** | ❌  | ✅  (2번) |
    | **레지스터(Register)** | ✅  | ❌  |
    | **레지스터 간접(Register Indirect)** | ✅  | ✅  |

> ✔️ **즉시(Immediate) 방식** → 메모리 필요 없음 (데이터가 명령어에 직접 포함됨)
> 
> 
> ✔️ **직접(Direct) 방식** → **메모리에 데이터가 있어야 함** (명령어가 메모리 주소를 직접 가리킴)
> **즉시 방식은 메모리와 관계없이 바로 값을 가져올 수 있지만, 직접 방식은 반드시 메모리에 값이 있어야 한다!** 
> 

### 스택과 큐

- **스택** *stack*
    - **LIFO** *Last In First Out 리포*  = **후입 선출**
        - 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식
    - push, pop
- **큐** *queue*
    - **FIFO** *First In First Out* *피포* = **선입 선출**
        - 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식

## 추가 개념

> ### ✅ 자바의 실행 과정 (컴파일 + 인터프리트)  
> 1. **컴파일 단계**  
>     - `.java` 소스 코드 → **Javac(자바 컴파일러)** → **바이트코드(.class)**  
>     - 바이트코드는 CPU가 직접 실행할 수 있는 기계어가 아니라 **JVM이 이해할 수 있는 중간 코드**  
>  2. **인터프리트 단계**  
>     - `.class` 바이트코드 → **JVM(자바 가상 머신)이 인터프리팅하여 실행**  
>     - JVM이 바이트코드를 읽고 **기계어로 변환하여 실행** (이 과정이 인터프리트 방식)  
>     - 최신 JVM에서는 **JIT(Just-In-Time) 컴파일러**를 사용하여 실행 속도를 최적화함  
> 
> ### 결론  
> 
> 자바는 "`컴파일 언어 + 인터프리터 언어`"의 특징을 모두 가짐  
> 
> - 컴파일 단계에서 바이트코드로 변환되므로 **컴파일 언어의 특징**을 가짐  
> - 바이트코드를 실행할 때 JVM이 기계어로 변환하며 실행하므로 **인터프리터 언어의 특징**도 있음  
> 
> 즉, 자바는 "**바이트코드를 이용해 플랫폼 독립성을 제공**하면서도 **JIT 컴파일러로 성능을 높이는 방식**"을 사용  

<br>

> ### ✅ JIT(Just-In-Time) 컴파일러란?  
> JIT(Just-In-Time) 컴파일러는 **인터프리터 방식의 단점을 보완하기 위해 도입된 기술**로, **바이트코드를 실행 도중에 기계어로 변환하여 실행 속도를 높이는 역할**    
> 
> 🔸 **JIT 컴파일러의 동작 방식**  
> - 자바 프로그램 실행 과정에서, **JVM(Java Virtual Machine)**은 기본적으로 바이트코드를 한 줄씩 해석(**인터프리트**)하면서 실행    
> - but, **JIT 컴파일러는 실행 도중 자주 사용되는 코드(핫스팟, Hotspot)를 감지하고, 해당 코드를 한 번에 기계어로 변환한 뒤 캐싱하여 재사용**  
> 
> 🔸 **실행 과정**  
> 1. `.java` → **Javac(컴파일러)** → `.class` (바이트코드 생성)  
> 2. JVM이 바이트코드를 **인터프리트하며 실행**  
> 3. 특정 코드가 **자주 실행됨(핫스팟 코드)**  
> 4. JIT 컴파일러가 해당 바이트코드를 **기계어로 변환하여 캐싱**  
> 5. 이후 동일한 코드 실행 시 **바로 기계어를 실행**하여 속도 향상  
> 
> 🔸 **JIT의 장점**  
> 1. **실행 속도 향상**: 인터프리터 방식보다 빠르게 실행됨  
> 2. **최적화 적용**: 코드 분석 후 최적화된 기계어를 생성  
> 3. **반복되는 코드의 성능 개선**: 캐싱된 기계어 사용  
> 
> 🔸 **JIT의 단점**  
> 1. **초기 실행 속도 느림**: 변환하는 과정에서 약간의 오버헤드 발생  
> 2. **메모리 사용량 증가**: 기계어 코드 캐싱으로 인해 추가적인 메모리 소모  
> 
> 🔸 **JIT이 적용된 JVM 엔진**  
> - **HotSpot JVM** (Oracle, OpenJDK) 
>     - 가장 널리 사용되는 JVM으로, JIT을 사용하여 성능을 향상시킴  
> - **GraalVM**  
>     - 최신 JVM 기술로, 기존 HotSpot보다 더 나은 성능을 제공  
> 
> ### 🔸 요약  
> JIT 컴파일러는 “자주 실행되는 코드를 미리 기계어로 변환하여 속도를 높이는 JVM 최적화 기술"로, **인터프리터의 유연성과 컴파일 방식의 속도를 모두 활용하는 방식**


<br>

> ### ✅**링킹(Linking)이란?**  
> 링킹(Linking)은 프로그램을 실행 가능한 **완전한 실행 파일(목적 코드 + 라이브러리 등)**로 만드는 과정  
> 
> 🔸 **링킹이 필요한 이유**  
> 소스 코드가 컴파일되면 **목적 코드(Object Code, 기계어)**가 생성되는데, 이 상태로는 실행할 수 없음  
> 이유는? → **필요한 함수나 라이브러리가 포함되지 않았기 때문!**  
> 링커(Linker)는 여러 개의 목적 코드와 라이브러리를 **연결(Linking)하여 하나의 실행 파일을 생성**  
> 
> 🔸 **링킹의 두 가지 종류**  
>   1️⃣ **정적 링크(Static Linking)**  
> - 프로그램 실행 전에 **모든 라이브러리 코드**를 실행 파일에 포함  
> - 실행 파일 크기가 커짐  
> - 실행 시 별도의 라이브러리 파일이 필요 없음  
> - 예: C 언어에서 `gcc -static` 옵션 사용  
>   2️⃣ **동적 링크(Dynamic Linking)**  
> - 프로그램 실행 중에 **필요한 라이브러리를 불러옴** (공유 라이브러리 사용)  
> - 실행 파일 크기가 작아짐  
> - 실행할 때 시스템에 라이브러리가 존재해야 함  
> - 예: `.dll` (Windows), `.so` (Linux), `.dylib` (Mac) 사용  
> 
> 🔸 **자바에서는 링킹이 필요할까?**  
> 자바는 컴파일 후 `.class` 바이트코드를 생성하지만, 실행 시 **JVM이 동적으로 필요한 라이브러리를 로딩하기 때문에 전통적인 링킹 과정이 없음**  
> 즉, **자바는 동적 링크 방식**을 사용
> 
> ### 🔸 **정리**    
> -  **링킹**은 목적 코드(Object Code)와 필요한 **라이브러리를 연결**하여 실행 파일을 만드는 과정  
> -  **정적 링크**는 실행 파일에 모든 코드 포함 → 독립적 실행 가능하지만 크기 큼  
> -  **동적 링크**는 실행 중 라이브러리 로드 → 실행 파일 크기가 작고 유지보수 쉬움  
> -  **자바는 실행 시점에 필요한 라이브러리를 동적으로 로딩하는 방식** (전통적 링킹 과정 X)  
