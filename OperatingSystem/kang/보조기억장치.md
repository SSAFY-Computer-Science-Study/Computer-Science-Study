## 07-1. 다양한 보조기억장치

> `하드 디스크`   `플래터`   `데이터 접근 시간`   `플래시 메모리`   `페이지`   `블록`
> 


### 하드 디스크 *HDD; Hard Disk Drive*

![Image](https://github.com/user-attachments/assets/4e013e4a-b4f7-4f89-98de-eb24e234fef2)

- 자기적인 방식으로 데이터를 저장하는 보조기억장치
- **자기 디스크** *magnetic disk* 의 일종
- CD나 LP와 비슷하게 동그란 원판에 데이터를 저장하고, 그것을 회전시켜 뾰족한 리더기로 데이터를 읽음
- 플래터, 스핀들, 헤드, 디스크 암으로 구성
- **플래터** *platter*
    - 하드디스크에서 실질적으로 정보가 저장되는 곳
    - 플래터는 자기 물질로 덮여 있어 수많은 N극과 S극을 저장하며, N극과 S극이 0과 1의 역할을 수행
    
    ![Image](https://github.com/user-attachments/assets/e25ac69e-306a-4389-9c23-ad88e3e33d3e)
    
- **스핀들** *spindle*
    - 플래터를 회전시키는 구성 요소
    - 스핀들이 플래터를 돌리는 속도 = **분당 회전수** = **RPM** *Revolution Per Minute* 단위로 표현
- **헤드** *head*
    - 플래터의 데이터를 읽고 쓰는 구성 요소 (디스크 암에 부착)
    - 플래터 위에 미세하게 떠 있는 채로 데이터를 읽고 쓰는 바늘같이 생긴 부품
- **디스크 암** *disk arm*
    - 헤드를 원하는 위치로 이동시키는 구성 요소
    - 일반적으로  하드 디스크는 많은 양의 데이터를 저장해야 하므로 일반적으로 여러 겹의 플래터로 이루어져 있고 양면을 모두 사용할 수 있음
        - 양면 플래터를 사용하면 위아래로 플래터당 두 개의 헤드가 사용
        - 이 때 일반적으로 모든 헤드는 디스크 암에 부착되어 다같이 이동 (디스크 암은 한 곳에 모여 있고, 플래터가 동일한 속도로 다 같이 돌아간다)
    
    ![Image](https://github.com/user-attachments/assets/d582658d-323e-46df-bf63-bc4dc5948db4)
    
- **플래터의 데이터 저장 단위**
    - **트랙** *track*
        - 플래터를 여러 동심원으로 나누었을 때 그 중 하나의 원
    - **섹터** *sector*
        - 트랙을 피자처럼 쪼갰을 때 한 조각
        - **하드 디스크의 가장 작은 전송 단위**
        - 일반적으로 512Byte 정도인데 하드 디스크에 따라 차이가 있음 (4,096Byte도 있음)
    - **실린더** *cylinder*
        - 여러 겹의 플래터 상에서 같은 트랙이 위치한 곳(원통모양)을 모아 연결한 **논리적 단위**
        - 연속된 정보는 보통 한 실린더에 저장 → 디스크 암의 이동을 최소화하여 데이터 접근
            - 두 개의 플래터를 사용하는 하드 디스크에서 네 개의 섹터에 데이터를 저장할 때는 1플래터의 앞, 뒤, 2플래터의 앞, 뒤에 저장
- **하드 디스크가 저장된 데이터에 접근하는 시간**
    - **탐색 시간** *seek time*
        
        ![Image](https://github.com/user-attachments/assets/0dce1aa8-e117-4741-b252-a949a52150ef)
        
        - 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
        - 단일 헤드 디스크(이동 헤드 디스크)의 경우에만 존재,  다중 헤드 디스크(고정 헤드 디스크)의 경우 0
    - **회전 지연** *rotational latency*
        
       ![Image](https://github.com/user-attachments/assets/54773981-0081-472b-a9ca-5fa62274fdfa)
        
        - 헤드가 있는 곳으로 플래터를 회전시키는 시간
    - **전송 시간** *transfer time*
        
        ![Image](https://github.com/user-attachments/assets/09cad546-ee1d-4986-b134-f547db3ba890)
        
        - 하드 디스크와 컴퓨터 간의 데이터를 전송하는 시간
    - 위 시간들은 성능에 큰 영향을 끼치는 시간

하드 디스크의 성능은 많이 향상되었지만, 하드 디스크에서 다량의 데이터를 탐색하고 읽어들이는 시간은 상당함

> **탐색 시간과 회전 지연을 단축**시키기 위해서는 플래터를 빨리 돌려 **RPM을 높이는 것**도 중요하지만, **참조 지역성**(접근하려는 데이터가 플래터 혹은 헤드를 조금만 옮겨도 접근할 수 있는 곳에 위치하는 것)도 중요
> 

> ### 💡다중 헤드 디스크와 고정 헤드 디스크  
> 
> 플래터의 한 면당 헤드가 하나씩 달려 있는 하드 디스크 → **단일 헤드 디스크(single-head disk)**  
> 헤드가 트랙별로 여러 개 달려 있는 하드 디스크 → **다중 헤드 디스크(multiple-head disk)**  
> 다중 헤드 디스크는 트랙마다 헤드가 있기 때문에 탐색 시간이 들지 X → 탐색 시간 0  
> 이런 점에서 헤드를 움직일 필요가 없는 다중 헤드 디스크 = **고정 헤드 디스크(fixed-head disk)**
> ↔ 단일 헤드 디스크 = **이동 헤드 디스크(movalble-head disk)**    
>   
> ![Image](https://github.com/user-attachments/assets/aeab639e-ecc6-44f4-a4b3-dc74aac058fc)  

### 플래시 메모리 *flash memory*

![붉은 박스 부분](https://github.com/user-attachments/assets/7bb56e22-ee45-4581-8f9d-acfc4007b2f0)

붉은 박스 부분

- 하드 디스크 외에 **플래시 메모리** *flash memory* 기반의 보조기억장치 또한 많이 사용
- USB 메모리, SD 카드, SSD 등
- 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반 저장 장치
- 플래시 메모리는 보조기억장치의 범주를 넘어 다양한 곳에 널리 사용
→ 주기억장치인 ROM에도 사용되고, 거의 모든 전자제품 안에 플래시 메모리가 내장


> ### 💡 두 종류의 플래시 메모리
> 
> 플래시 메모리에는 크게 NAND 플래시 메모리와 NOR 플래시 메모리가 있음.
> NAND 연산을 수행하는 회로(NAND 게이트) 기반으로 만들어진 - NAND 플래시
> NOR 연산을 수행하는 회로(NOR 게이트) 기반으로 만들어진 - NOR 플래시

- **NAND 플래시** 메모리는 대용량 저장 장치로 많이 사용
- 보조 기억장치로도 사용

- **셀** *cell*
    - **플래시 메모리**에서 **데이터를 저장하는 가장 작은 단위**
    - 이 셀들이 모여 MB, GB 등의 용량을 갖는 저장 장치가 됨
- **하나의 셀에 몇 비트를 저장할 수 있느냐**에 따라 플래시 메모리의 종류가 나뉨
    - 플래시 메모리의 수명, 속도, 가격에 큰 영향
    - SLC, MLC, TLC, QLC
    - 사람 한 명을 비트, 셀을 집에 비유
    - **SLC** *Single Level Cell*
        - 한 셀에 1비트를 저장할 수 있는 플래시 메모리
        - 한 셀로 두 개의 정보 표현 가능 (0, 1)
        - 비트의 빠른 입출력 가능, 수명도 길어서 수만~수십만에 가까이 데이터 쓰고 지울 수 O
        - 용량 대비 가격이 높음
        - 보통 기업에서 데이터 읽고 쓰기가 매우 많이 반복되며 고성능의 빠른 저장 장치가 필요한 경우에 사용
    - **MLC** *Multiple Level Cell*
        - 한 셀에 2비트를 저장할 수 있는 플래시 메모리
        - 한 셀로 4개의 정보 표현 가능 (00, 01, 10, 11)
        - SLC 타입에 비해 속도와 수명은 떨어지지만
        - 대용량화하기 유리하고 가격이 저렴
        - 많은 플래시 메모리 저장 장치들이 MLC(혹은 TLC 타입)
    - **TLC** *Triple Level Cell*
        - 한 셀에 3비트를 저장할 수 있는 플래시 메모리
        - 한 셀로 8개의 정보 표현 가능(000~111)
        - 수명과 속도는 떨어지지만, 대용량화 하기 유리하고 가격이 저렴
        - 저가의 대용량 저장 장치를 원한다면 사용
    
    ![Image](https://github.com/user-attachments/assets/30fe593b-ccef-461e-a54b-630e17b58792)
    

> ### 💡플래시 메모리도 수명이 있나요? ⭕  
>   
> 플래시 메모리는 수명이 있음. 하드 디스크 또한 수명이 있음  
> USB, SSD, SD 카드는 수명이 다하면 더 이상 저장장치로써 사용 불가  
> 한 셀에 일정 횟수 이상 데이터를 쓰고 지우면 그 셀은 더 이상 데이터를 저장 X
> 

- **플래시 메모리의 저장단위**
    
    ![Image](https://github.com/user-attachments/assets/d82c986f-ebad-4781-8b32-f8353e7a71a9)
    
    - 셀들이 모이면 **페이지** *page*
    - 페이지들이 모이면 **블록** *block*
    - 블록들이 모이면 **플레인** *plane*
    - 플레인들이 모이면 **다이** *die*

> 플래시 메모리의 **읽기/쓰기**는 **페이지** 단위로 이루어지지만 **삭제**는 **블록 단위**로 이루어진다.
> 
- 페이지의 세 가지 상태
    - **Free** 상태
        - 어떤 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
    - **Valid** 상태
        - 이미 유효한 데이터를 저장하고 있는 상태
        - 덮어쓰기가 불가능하여 이 상태인 페이지에 새 데이터 저장X
    - **Invalid** 상태
        - 유효하지 않은 데이터(쓰레기값)를 저장하고 있는 상태
    - **플래시 메모리는 하드 디스크와 달리 덮어쓰기가 불가능**하여 Valid 상태인 페이지에는 새 데이터 저장X
- **예)** 블록 x 는 4개의 페이지로 구성
    - 데이터 C 저장 (페이지 단위)
    
    ![Image](https://github.com/user-attachments/assets/4cb9a0ed-55ab-4430-a1ce-72a5c7cb3609)
    
    - 기존 A를 A’로 수정하고 싶다면?
        
        ![Image](https://github.com/user-attachments/assets/7944baa1-1610-40ad-ac7b-d394fd359fac)
        
        - 덮어쓰기 불가능이므로 기존에 저장된 A는 Invalid 상태의 쓰레기 값으로 만들고 A’를 새롭게 저장
        - Invalid 상태인 페이지(A)는 용량을 차지 → 공간 낭비
        - but, A만 지울 수 X (삭제는 블록 단위)
        - **→** 최근 SSD를 비롯한 플래시 메모리는 이런 쓰레기값을 정리하기 위해 **가비지 컬렉션 *garbage collection*** 기능 제공
    - **가비지 컬렉션**
        
        ![Image](https://github.com/user-attachments/assets/b174af01-8ec2-403f-8ed5-00497ee0ffb8)
        
        1. 유효한 페이지만 새로운 블록으로 복사
        2. 기존 블록을 삭제

## 07-2. RAID의 정의와 종류

> `RAID`   `RAID0`   `RAID1`    `RAID4`    `RAID5`    `RAID6`
> 

RAID를 이용하면 1TB 하드디스크 4개가 4TB 하드디스크 1개를 뛰어넘음

### RAID의 정의

정보량이 많고 민감한 정보도 많아 안전하게 관리할 필요가 있을 때

→ 하드 디스크와 같은 보조기억장치에 어떻게든 저장하면 된다X (수명이 있기 때문)

→ RAID를 사용하면 된다!

> **RAID *Redundant Array of Independent Disks*** 
데이터의 안전성 혹은 높은 성능을 위해 여러 개의 **물리적 보조기억장치**를 마치 **하나의 논리적 보조기억장치**처럼 사용하는 기술
주로 하드 디스크와 SSD를 사용해서 구현
> 

### RAID의 종류

**RAID 구성 방법** =  **RAID 레벨**

대중적인 ⇒ RAID 0, 1, 4, 5, 6 (2, 3은 거의 사용x)

- **RAID 0**
    - 여러 개의 보조기억장치에 데이터를 단순히 나누어 저장하는 구성 방식
    - 데이터 저장 시 각 하드 디스크는 번갈아가면 데이터를 저장
    → 저장되는 데이터가 하드 디스크 개수만큼 나뉘어 저장
    - 줄무늬처럼 분산되어 저장된 데이터를 **스트라입** *stripe →* 분산하여 저장하는 것을 **스트라이핑** *striping*
    - 스트라이핑되면 저장된 데이터를 읽고 쓰는 속도가 빨라짐
        - 하나의 대용량 저장 장치를 이용했더라면 여러 번에 걸쳐 읽고 썼을 데이터를 동시에 읽고 쓸 수 있기 때문(A1, A2, A3, A4를 동시에 읽기 가능)
        - 4TB 1개 보다 RAID 0으로 구성된 1TB 저장장치 속도가 이론상 4배 빠름
    - 단점
        - 저장된 정보가 안전하지 X
        - 구성된 하드 디스크 중 하나라도 문제가 생기면 모든 하드 디스크의 정보 읽기에 문제 발생
    
    ![Image](https://github.com/user-attachments/assets/53849840-5d03-4499-8770-c2f5c7c10d0d)
    
- **RAID 1**
    - RAID 0의 문제를 보완
    - **복사본**을 만드는 구성 방식
    - 완전한 복사본을 만드는 구성이기에 **미러링** *mirroring*
    - 같은 데이터를 두 군데 쓰기 때문에 쓰기 속도는 RAID 0에 비해 느림
    - 하나의 디스크가 문제가 생겨도 복구가 수월(복사본)
    - 단점
        - 사용 가능한 용량(절반)이 줄어 많은 양의 하드 디스크가 필요 → 비용 증가
    
    ![Image](https://github.com/user-attachments/assets/d74465cf-0b58-4668-a575-370b89733961)
    
- **RAID 4**
    - 완전한 복사본을 만드는 대신 오류 검출 및 복구를 위한 정보를 저장하는 장치를 두는 구성 방식
    - 오류 검출 및 복구를 위한 정보 - **패리티 비트** *parity bit*
        - 패리티를 저장한 장치를 이용해 다른 장치의 오류를 검출하고, 있으면 복구
    - RAID 1보다 적은 하드 디스크로 데이터를 안전하게 보관 가능
    - 새로운 데이터를 저장할 때마다 패리티를 저장하는 디스크에도 데이터를 써야하므로 병목현상이 발생
    
    ![Image](https://github.com/user-attachments/assets/19e68538-032a-4e6b-8712-3a20dd3d44c2)
    
    > ### 💡 오류를 검출하는 패리티 비트  
    > 원래 패리티 비트는 오류 검출만 가능할 뿐 오류 복구는 불가X  
    > → RAID에서는 가능  
    > 
    
- **RAID 5**
    - RAID 4의 병목 현상 문제를 보완하기 위한 방식
    - **패리티 정보를 분산하여 저장**하는 구성 방식
    
    ![Image](https://github.com/user-attachments/assets/a173df27-67e8-47a5-8914-d1ee45eff878)
    
- **RAID 6**
    - 기본적으로 RAID 5와 같으나 **서로 다른 두 개의 패리티를 사용**하여 보다 안전하게 만든 구성 방식
    - 새로운 정보 저장 시 함께 저장할 패리티가 2개이므로 → 쓰기 속도는 RAID 5보다 느림
    - 저장 속도를 조금 희생하더라도 데이터를 더욱 안전하게 보관하고자 할 때 사용
    ![Image](https://github.com/user-attachments/assets/d5fcc62d-17d8-46d2-9c7d-e8bd0265a124)

- Nested RAID
    - RAID 레벨 혼합방 식
    - RAID0 + RAID1 = RAID 10, RAID 0 + RAID5 = RAID5도 있음
- 각 RAID 레벨마다 장단점이 있으므로 상황에 따라 최적의 RAID 레벨을 선택하여 사용

## 추가 개념

> ### ✅ 패리티 비트
> 
> **오류 검출**을 위한 기법으로 데이터 전송 또는 저장 중에 오류가 발생했는지를 확인하는 데 사용. 패리티 비트는 데이터가 올바르게 전송되었는지 확인하는 중요한 역할을 하지만, 그 자체로는 **오류 복구**를 할 수 없음. 그러나 RAID(레드undant Array of Independent Disks)에서는 패리티 비트를 사용하여 **오류 검출뿐만 아니라 오류 복구도 가능**하게 만듦. 
> 
> ### 1. 패리티 비트의 기본 개념
> 
> 패리티 비트는 데이터를 저장하거나 전송할 때 그 데이터의 **비트 수**가 **홀수** 또는 **짝수**가 되도록 추가되는 비트
> 
> - **홀수 패리티 (Odd Parity):** 데이터의 비트 수가 홀수가 되도록 패리티 비트를 추가
> - **짝수 패리티 (Even Parity):** 데이터의 비트 수가 짝수가 되도록 패리티 비트를 추가
> 
> 예를 들어,  "1011010"을 짝수 패리티로 처리한다고 가정하면, 원본 데이터(7bit)의 1은 짝수이므로 패리티 비트 0을 추가해서 “1011010(0)”이 된다. 수신자는 전체 비트의 1의 개수를 확인하고 짝수이므로 오류가 없다고 판단.
> 전송 중에 오류가 발생하여 1개의 비트가 바뀌었을 경우 “101111(0)”으로 도착한 경우, 전체 비트(8bit)의 1의 개수가 홀수 이므로 오류가 발생한 것을 알 수 있음.
> 
> ### 2. RAID에서 패리티를 사용한 오류 검출 및 복구
> 
> RAID에서는 패리티를 더 복잡한 방식으로 사용하여, 단순히 오류를 **검출하는 것뿐만 아니라**, **오류가 발생한 데이터를 복구**하는 데도 활용. RAID는 하나의 드라이브가 고장나더라도 데이터를 복구할 수 있음.
> 
> ### 3. 패리티를 사용한 오류 복구의 원리
> 
> RAID에서 패리티 비트를 사용해 오류를 복구하는 기본 원리는 **XOR 연산**. XOR(배타적 논리합)은 두 개의 비트가 같으면 0, 다르면 1을 반환하는 연산. 
> 
> 1. **패리티 비트**는 **여러 드라이브의 데이터를 XOR 연산한 결과**.
> 2. 만약 하나의 드라이브가 고장나면, 고장난 드라이브의 데이터는 나머지 드라이브의 데이터와 패리티를 이용해 XOR 연산으로 복구.
> 
> ### 4. RAID에서 패리티의 장점과 한계
> 
> - **장점:** 패리티를 사용하면 적은 수의 드라이브만으로도 데이터 보호. 예를 들어, RAID 5는 **하나의 드라이브**만 고장 나도 복구가 가능.
> - **한계:** 패리티를 계산하고 데이터를 복구하는 데 시간이 걸림. 또한, 두 개 이상의 드라이브가 동시에 고장 나는 경우, 데이터 복구가 불가능 (RAID 5는 최대 1개 드라이브 고장, RAID 6은 최대 2개 드라이브 고장까지 복구 가능).
>

> ### ✅ RAID 레벨 - 용량 계산
> 
> | RAID 수준 | 최소 드라이브 수 | 용량 계산 공식 | 예시 (1TB 드라이브 기준) |
> | --- | --- | --- | --- |
> | RAID 0 | 2개 이상 | 총 용량 = 드라이브 수 × 각 드라이브 용량 | 3TB (3개 드라이브) |
> | RAID 1 | 2개 이상 | 총 용량 = 드라이브 수 / 2 × 각 드라이브 용량 | 1TB (2개 드라이브) |
> | RAID 4 | 3개 이상 | 총 용량 = (드라이브 수 - 1) × 각 드라이브 용량 | 2TB (3개 드라이브) |
> | RAID 5 | 3개 이상 | 총 용량 = (드라이브 수 - 1) × 각 드라이브 용량 | 3TB (4개 드라이브) |
> | RAID 6 | 4개 이상 | 총 용량 = (드라이브 수 - 2) × 각 드라이브 용량 | 3TB (5개 드라이브) |
