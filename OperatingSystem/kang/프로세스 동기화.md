# 12. 프로세스 동기화
## 12-1. 동기화란

> `동기화`   `공유 자원`   `임계 구역`   `상호 배제`
> 

동시다발적으로 실행되는 프로세스들은 서로 데이터를 주고 받으며 협력하며 실행될 수도 있다.

프로세스들은 **실행 순서와 자원의 일관성 보장**을 위해 반드시 **동기화** *synhronization*되어야 한다.

### 동기화의 의미

프로세스의 올바른 실행을 위해서는 동기화가 필수

- **프로세스의 동기화**
    - 프로세스들의 **`수행 시기`**를 맞추는 것
    - **실행 순서 제어**
        - 프로세스를 올바른 순서대로 실행하기
        - 어떤 프로세스가 완료되고 나서야 그 이후에 실행 가능한 다른 프로세스가 실행되도록 한다
    - **상호 배제**
        - 동시에 접근해서는 안 되는 자원에 **하나의 프로세스만 접근**하게 하기
        - 공유 불가능한 자원의 동시 사용을 피하는 것이 **상호 배제** *mutual exclusion*
        - **생산자와 소비자 문제** (상대의 작업 끝나기 전에 "총합" 데이터 수정하는 이슈)
    
    ![image](https://github.com/user-attachments/assets/9939da51-edd7-4d53-a18e-5f66af4ee514)

> 프로세스뿐만 아니라 스레드도 **동기화 대상**
→ **실행의 흐름을 갖는 모든 것**은 동기화의 대상
> 

### 공유 자원과 임계 구역

- **공유 자원** *shared resource*
    - 협력하는 프로세스가 **공동**으로 사용하는 **자원**
    - 전역 변수, 파일, 입출력장치 등
    - 공유 자원에 대한 동시 접근이 동기화 문제를 야기할 수 있음
- **임계 구역** *critical section*
    - **동시에 실행하면 문제가 발생**하는 **자원에 접근하는 코드 영역**
    - 둘 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야 함
    - 임계 구역에 먼저 진입한 프로세스의 작업이 마무리되면 다른 프로세스가 임계 구역에 진입
        
       ![image](https://github.com/user-attachments/assets/2745a43e-736b-4269-9d01-0c01786aa524)

        
- **레이스 컨디션** *race condition*
    - 둘 이상의 프로세스가 동시에 실행되면 안 되는 영역이지만, 잘못된 실행으로 인해 여러 프로세스가 **동시 다발적으로 임계 구역의 코드를 실행**하여 문제가 발생하는 경우
    - 레이스 컨디션이 발생하는 근본적인 **이유**
        - 고급 언어는 실행 과정에서 저급 언어로 변환되어 실행된다
        - 예) 총합 1 증가 → 여러 줄의 **저급 언어**로 변환
        - 컴퓨터가 여러 줄의 저급 언어로 변환된 고급 언어 한 줄을 실행하는 과정에서 **문맥 교환**이 일어날 수 있음 → 레이스 컨디션이 발생할 수 있음

운영체제는 임계 구역 문제를 다음과 같은 세 가지 원칙 하에 해결한다.

**상호 배제를 위한 동기화** → 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것

- **상호 배제** *mutual exclution*
    - 한 프로세스가 임계 구역 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
- **진행** *progress*
    - 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 **들어갈 수 있어야** 한다.
- **유한 대기** *bounded waiting*
    - 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 무한정 대기하지 않고 언젠가는 들어갈 수 있어야 한다. (무한정 대기해서는 안된다.)

## 12-2. 동기화 기법

> `뮤텍스 락`   `세마포어`   `모니터`
> 

프로세스의 동기화를 위한 대표적인 도구

### 뮤텍스 락

*Mutex lock; MUTual EXclusion lock* 

- `상호 배제`를 위한 **동기화 도구**
- 임계 구역에 진입하는 프로세스는 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입
- 하나의 **전역 변수**와 두 개의 **함수**로 구현
    - **자물쇠 역할**: 프로세스들이 공유하는 전역 변수 `lock`
    - **임계 구역을 잠그는 역할**: `acquire` 함수
    - **임계 구역의 잠금을 해제하는 역할**: `release` 함수
- `acquire` 함수
    - 잠그는 역할
    - 프로세스가 임계 구역에 **진입하기 전에** 호출하는 함수
    - 임계 구역이 잠겨 있다면 `lock==false`가 될 때까지 반복적으로 확인
        
        > 이와 같이 기다리며 잠겨있는지 계속 확인하는 것을 **바쁜 대기** *busy wait*
        > 
    - 임계 구역이 열려 있다면 `lock=true` 하고 임계 구역 접근
    
    ```c
    acquire() {
        while (lock == true); // 잠겨 있는 동안 잠김 여부 계속 확인
        lock = true; // 열려 있으면 잠그고 함수를 빠져 나감
    }
    ```
    
- `release` 함수
    - 잠금 해제 역할
    - 임계 구역의 **작업이 끝나고** 호출하는 함수
    - 임계 구역을 열어 `lock=false` 하고 임계 구역을 벗어남
    
    ```c
    release() {
        lock = false; // 잠금 해제
    }
    ```
    
- 사용
    
    ```jsx
    acquire(); //잠겨 있는지 확인 후 잠그고 들어가기
    //임계 구역에서 작업 진행 //예) '총합' 변수 접
    release(); //자물쇠 반환
    ```
    
    - 락을 획득할 수 없다면(임계 구역에 진입 불가) → 무작정 기다림
    - 락 획득 가능(진입 가능) → 잠그고 임계 구역에서 작업 진행
    - 임계 구역 빠져나올 때 잠금 해제

> C/C++, python 등의 일부 프로그래밍 언어에서는 사용자가 직접 acquire, release 함수를 구현하지 않도록 (보다 정교한) 뮤텍스 락 기능을 제공
> 

### 세마포어

*semaphore*

- 조금 더 일반화된 방식의 동기화 도구
- **뮤텍스 락** → **하나의 공유 자원**에 접근하는 프로세스를 상정한 방식
- **`공유 자원이 여러 개` 있는 상황**에서도 적용 가능한 **동기화 도구**

> 엄밀히 말하면 세마포어의 종류에도 `이진 세마포어(binary semaphore)`와 `카운팅 세마포어(counting semaphore)`가 있음 → 이진 세마포어는 뮤텍스 락과 비슷한 개념
> 
- 세마포어의 유래
    - 기차 신호기
    - 신호 - 멈춤 / 가도 좋다
- 하나의 **전역 변수**와 두 개의 **함수**로 구현
    - **임계 구역에 진입할 수 있는 프로세스 개수(혹은 사용 가능한 공유 자원의 개수)**: 전역 변수 `S`
        - 처음에는 전체 자원 개수이며, 프로세스의 접근에 따라 변동된다.
    - **임계 구역 진입 가능 여부를 알려주는 역할**: `wait` 함수
    - **임계 구역 앞에서 기다리는 프로세스에게 `진입 가능`을 알려주는 역할**: `signal` 함수
    
    > 변수명과 함수명은 다를 수 있음. P, V 또는 down, up
    > 
1. `상호 배제`를 위한 동기화
- 사용
    
    ```jsx
    wait()
    // 임계 구역
    signal()
    ```
    
- `wait` 함수
    
    ```c
    wait() {
        while (S <= 0); // 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하이면
    								    // 사용할 수 있는 자원이 있는지 반복적으로 확인
        S--; // 진입 가능하다면(s >= 1) 진입 가능 프로세스 수를 1 줄이고 임계 구역에 진입
    }
    ```
    
    - 임계 구역에 진입하기 전에 호출하는 함수
    - 진입 가능한 프로세스가 없다면 `S > 0`가 될 때까지 반복적으로 확인
    - 진입 가능한 프로세스가 있다면 `S--`으로 진입 가능한 프로세스 수를 하나 줄이고 임계 구역 접근
    - 바쁜 대기로 인한 CPU 주기 낭비를 방지하기 위해 세마포어를 위한 대기큐 사용 가능
- `signal` 함수
    
    ```c
    signal() {
        S++; // 작업을 마친 뒤 진입 가능 프로세스 1 증가
    }
    ```
    
    - 임계 구역의 작업이 끝나고 호출하는 함수
    - `S--`으로 진입 가능한 프로세스 수를 늘리고 임계 구역을 벗어남
    - 바쁜 대기로 인한 CPU 주기 낭비를 방지하기 위해 세마포어를 위한 대기큐 사용 가능
- 3개의 프로세스 P1, P2, P3가 2개의 공유 자원에 P1, P2, P3 순서로 접근한다면?
    - 공유 자원 2개 → S = 2

![image](https://github.com/user-attachments/assets/be3a4fd3-2948-4b3b-aad4-616eccec928d)


- **발생 가능한 문제 (뮤텍스 락에도 해당)**
    - 사용할 수 있는 공유 자원이 없는 경우 프로세스는 **무작정 무한히 반복**하며 S를 확인해야 함
    - **바쁜 대기** → CPU 주기를 낭비
- 세마포어는 다른 방법을 사용
    - wait 함수는 사용할 수 있는 자원이 없을 경우 해당 프로세스를 `대기 상태`로 만들고, 그 프로세스의 PCB를 세마포어를 위한 `대기 큐`에 넣음
    - 프로세스가 임계 구역에서의 작업이 끝나고 `signal` 함수를 호출하면 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스를 준비 상태로 변경한 뒤 `준비 큐`로 옮김
        
        ```c
        wait() {
            S--;
            if (S < 0) {
                enQueue(); // 해당 프로세스의 PCB를 대기 큐에 삽입하는 가상의 함수
                sleep(); // 대기 상태 진입
            }
        }
        ```
        
        ```c
        signal() {
            S++;
            if (S <= 0) { // S > 0일 때는 대기 큐에서 기다리지 않고 다 잘 사용 중.
                p = deQueue(); // 대기 큐에서 프로세스 p를 제거하는 가상의 함수
                wakeup(p); // 프로세스 p를 대기 상태에서 준비 상태로 변경
            }
        }
        ```
        
- 큐를 이용한 방법 예시

![image](https://github.com/user-attachments/assets/7c57c814-48a9-42e4-b0b4-a2785d999243)


1. **실행 순서 제어**를 위한 동기화
    - 특정 조건이 만족되어야만 실행할 수 있는 상황에서 올바른 순서대로 실행하게 하는 것
    - 세마포어의 변수 `S`를 0으로 두고
    먼저 실행할 프로세스 뒤에 `signal` 함수, 다음에 실행할 프로세스 앞에 `wait` 함수를 붙이면 됨
        
       ![image](https://github.com/user-attachments/assets/df7db682-5beb-4963-ad90-21a8de366c19)

        
    - P1이 먼저 임계 구역에 진입하고, P2가 먼저 실행되더라도 P2는 `wait()` 함수를 만나므로 P1이 먼저 진입
    - P1이 실행을 끝내고 `signal()`을 호출하면 그제서야 P2가 진입
    - 누가 먼저 실행되든 반드시 P1 → P2의 순서대로 실행

### 모니터

*monitor* 

- 세마포어는 매번 임계 구역 앞뒤로 일일이 `wait`과 `signal` 함수를 명시해야 하므로 번거롭고, 잘못된 코드로 예기치 못한 결과가 발생할 수 있음
    
    ![image](https://github.com/user-attachments/assets/229f7d14-4162-4ff9-98c9-ab958f055e4f)

    
- 세마포어에 비해 사용자가 `사용하기 쉬운` **동기화 도구**
- **공유 자원**과 이에 접근하기 위한 **인터페이스(통로)**를 묶어서 관리
- 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근
- 모니터를 통해 공유 자원(인터페이스)에 접근하고자 하는 프로세스를 `큐`(모니터에 진입하기 위한 큐)에 삽입하고 `큐`에 삽입된 순서대로 **하나씩 공유 자원** 이용
- 모니터 안에 항상 하나의 프로세스만 들어오도록 **`상호 배제`를 위한 동기화**를 제공

![image](https://github.com/user-attachments/assets/144747e5-cc92-4475-ab95-a96bd7fca2a1)


- 프로세스의 `실행 순서를 제어 동기화를` 위한 특별한 변수 **조건 변수** *condition valiable*  사용
    - 특정 조건을 바탕으로 프로세스를 실행 및 일시 중단하여 실행 순서 제어 가능

> **모니터**가 **조건 변수**를 사용하지만 둘은 별개의 개념
> 
- **조건 변수**로는 `wait`과 `signal` 연산을 수행할 수 있음
- `wait`
    - 호출한 프로세스의 상태를 **대기 상태**로 전환하고 일시적으로 **`조건 변수`**에 대한 `대기 큐`에 삽입하는 연산
    - **모니터**에 진입하기 위해 삽입되는 **큐**(`상호 배제`를 위한 큐)와 `wait`가 호출되어 **실행이 중단**된 프로세스들이 삽입되는 **큐**(`조건 변수`에 대한 큐)는 다르다!
    - **모니터** 관련 큐
        - 한 번에 하나의 프로세스만 진입하도록
    - **조건 변수** 관련 큐
        - 모니터에 이미 진입한 프로세스의 **실행 조건이 만족**될 때까지 잠시 실행이 **중단**되어 기다리도록
- **예시**
    - 모니터에 진입한 어떤 프로세스가 어떤 조건 변수 `x`에 대한 `x.wait()` 함수 호출한다면?
    - 해당 **프로세스**는 조건 변수 `x`에 대한 **대기 큐**에 삽입되어 모니터는 빔
        
        ![image](https://github.com/user-attachments/assets/f5b2952f-c547-4e71-9f66-0d2e3f9fcee5)

        
    - → **다른 프로세스**가 **모니터** 접근 가능
    - `wait` 연산으로 **일시 중지된 프로세스**는 **다른 프로세스의** `signal` 연산을 통해 **실행이 재개**될 수 있음
    - `signal`은 `wait`을 호출하여 **큐**에 삽입된 프로세스의 **실행을 재개**하는 연산
- **예시2**
    - 어떤 프로세스가 `x.signal()` 을 통해 조건 변수 `x`에 대한 `signal`을 호출한다면?
    - 조건 변수 `x`에 대해 **대기 상태**에 있던 **프로세스가 깨어나** **모니터 안**으로 다시 들어올 수 있게 됨
        
        ![image](https://github.com/user-attachments/assets/924c3a89-ca1e-4f25-89b6-5532f2cf71af)

        
    - **모니터 안에는 하나의 프로세스**만 있어야 하므로 `wait`을 호출했던 프로세스는 `signal`을 호출한 프로세스가 **모니터를 떠난 뒤** 실행되거나
    - `signal`을 호출한 프로세스의 실행을 **일시 중단**하고 **자신이 실행**된 뒤 다시 `signal`을 호출한 프로세스의 수행을 **재개**함
- **모니터**는 `조건 변수`를 이용하여 **프로세스 실행 순서 제어**를 위한 **동기화**를 제공
    1. 특정 프로세스가 아직 실행될 조건이 충족되지 않았을 때 `wait` 함수를 통해 실행 중단
    2. 특정 프로세스가 실행될 조건이 충족되었을 때 `signal` 함수를 통해 실행 재개
