# 10. 프로세스와 스레드

## 10-1. 프로세스 개요

> `프로세스`   `프로세스 제어 블록`    `문맥 교환`   `프로세스 사용자 영역`
> 

> **프로세스** *process*
> 
> - 실행 중인 프로그램
> 
> 프로그램은 실행되기 전까지는 **보조기억장치**에 있는 데이터 덩어리일 뿐이지만, **메모리**에 적재하고 실행하는 순간 **프로세스**가 됨 → `프로세스 생성`
> 

### 프로세스 직접 확인하기

- 윈도우 - [작업 관리자] > [프로세스] or [서비스]
- 유닉스 - `$ ps -ef`

직접 실행한 프로세스 외에도 운영체제에 의해 실행되는 다양한 프로세스가 존재

- **포그라운드 프로세스** *foreground process*
    - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- **백그라운드 프로세스** *background process*
    - 보이지 않는 공간에서 실행되는 프로세스
        - 사용자와 직접 상호작용 할 수 있는 프로세스
        - **데몬** *daemon* - 유닉스
            - **상호작용하지 않고 정해진 작업을 수행하는 프로세스**
            - 윈도우 운영체제 -  **서비스** *service*

### 프로세스 제어 블록

모든 프로세스는 실행을 위해 CPU를 필요로 하지만

CPU 자원은 한정되어 있기에 프로세스들은 차례대로 돌아가며 한정된 시간만큼만 CPU를 이용

자기 차례가 되면 정해진 시간만큼 CPU를 이용하고, 시간이 끝났음을 알리는 인터럽트(**타이머 인터럽트**)가 발생하면 차례를 양보하고 다음 차례를 기다림

> ♻️ **타이머 인터럽트**(타임아웃 인터럽트)
>
>  - 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트


- **프로세스 제어 블록(PCB)** *process control block*
    - `운영체제`는 빠르게 번갈아 수행되는 **프로세스의 실행 순서**를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분 → 이를 위해 PCB를 이용
    - `프로세스와 관련된 정보를 저장`하는 자료 구조
    - 해당 프로세스를 **식별**하기 위해 꼭 필요한 정보들을 저장 (상품 택)
        - 운영체제도 수많은 프로세스들 사이에서 PCB로 특정 프로세스를 식별하고, 프로세스 처리에 필요한 정보를 판단
    - 메모리의 **커널 영역**
    - PCB는 프로세스 생성 시 만들어지고 실행이 끝나면 폐기
    - 새로운 프로세스 생성 = 운영체제가 PCB 생성
    - 프로세스 종료 = 운영체제가 PCB 폐기

### **— PCB에 담기는 정보**

*(운영체제마다 차이가 있음)*

- **프로세스 ID** ***PID**; process ID*
    - 프로세스를 식별하기 위해 부여하는 고유한 번호
    - 같은 프로그램도 두 번 실행하면 PID가 다른 두 개의 프로세스 생성
- **레지스터 값**
    - 프로세스는 자기 차례가 돌아오면 이전까지 사용했던 레지스터 중간값들을 복원해야
    이전까지 진행했던 작업들을 그대로 이어 실행 가능
    - 해당 프로세스가 실행하며 사용했던 PC를 비롯한 **레지스터 값**들을 저장
- **프로세스 상태**
    - 프로세스가 입출력 장치 사용을 위해 기다리고 있는지, CPU를 이용하고 있는지 등의 정보
- **CPU 스케줄링 정보**
    - 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
- **메모리 관리 정보**
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 베이스 레지스터, 한계 레지스터 값
    - 페이지 테이블 정보 `14장`
- **사용한 파일과 입출력장치 목록**
    - 프로세스가 실행과정에서 사용한 입출력장치나 파일 내역
        - 어떤 입출력장치가 이 프로세스에 할당되었는지, 어떤 파일을 열었는지

![image](https://github.com/user-attachments/assets/a1f2f0d8-0d7e-4370-be6e-e85e2ef963a8)


### 문맥 교환

어떤 프로세스가 실행되다가 다른 프로세스에게 CPU 자원을 양보하는 상황에서

바로 직전까지 실행되던 프로세스는 사용하던 레지스터 값, 메모리 정보 등 **중간 정보(context)**를 백업해야 함

그래야 다음 차례에 이어서 실행 가능

- **문맥** *context*
    
    > 하나의 프로세스 수행을 재개하기 위해 기억해야 할 **중간 정보**
    > 
    - 하나의 프로세스 문맥은 해당 프로세스 **PCB**에 표현되어 있음
        - `PCB에 기록되는 정보` = **문맥 ***context*
    - 프로세스의 CPU 사용 시간이 다 되거나 예기치 못한 상황이 발생하여 인터럽트가 발생하면 `운영체제`가 해당 **프로세스의 `PCB`**에 **`문맥`**을 **백업**
    - 뒤이어 실행할 프로세스의 문맥을 복구하면 자연스럽게 실행되는 프로세스가 바뀜
    
    ![image](https://github.com/user-attachments/assets/f674b3cd-2576-47f0-8a06-84124fc379c4)

    
- **문맥 교환** *context switching*
    - 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
    - 여러 프로세스가 끊임없이 빠르게 번갈아가면 수행
    - 문맥 교환이 자주 일어나면 마치 프로세스들이 `동시에 실행되는 것처럼` 보임
    
    > ♻️
    > 
    > 문맥 교환을 너무 자주하면 오버헤드가 발생할 수 있기 때문에
    > 문맥 교환이 자주 일어난다고 해서 반드시 좋은 것은 아님
    > 
    

### 🔥  프로세스의 메모리 영역

**프로세스**가 생성되면 `커널` 영역에 **PCB**가 생성

하나의 **프로세스**는 `사용자` 영역에 크게 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장

![image](https://github.com/user-attachments/assets/8f25918b-89fe-4834-a0c1-1ade7c592948)


- **정적 할당 영역**
    - 프로그램이 실행되는 동안 크기가 변하지 않는 영역
    - **코드 영역** *code segment* (**텍스트 영역** *text segment*)
        - 실행할 수 있는 코드 = 기계어로 이루어진 **`명령어`**가 저장
        - 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기 금지
        → 읽기 전용 *read-only*공간
    - **데이터 영역** *data segment*
        - **전역 변수**와 같이 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- **동적 할당 영역**
    
    ![image](https://github.com/user-attachments/assets/1193b3ff-93cd-4713-8d27-6921498020f6)
    
    - 프로그램이 실행되는 동안 크기가 변할 수 있는 영역
    - **힙 영역** *heap segment*
        - 프로그래머가 직접 할당할 수 있는 공간
        - 프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했다면 언젠가는 **`반환`**해야 함
            - 반환 = 운영체제에게 메모리 공간 안써요라고 알림
        - **메모리 누수** *memory leak*
            - 반환하지 않는다면 메모리 낭비
        - 일반적으로 메모리의 낮은 주소에서 높은 주소로 할당
    - **스택 영역** *stack segment*
        - 잠깐 쓰다가 말 데이터를 **일시적**으로 저장하는 공간
        - 함수의 실행이 끝나면 사라지는 **매개 변수, 지역 변수** 등
        - 일시적으로 저장할 데이터를 PUSH, 더 이상 필요하지 않은 데이터를 POP
        - 일반적으로 메모리의 높은 주소에서 낮은 주소로 할당
        

<br>


## 10-2. 프로세스 상태와 계층 구조

> `프로세스 상태`   `부모 프로세스`   `자식 프로세스`   `프로세스 계층 구조`
> 

프로세스는 실행 중, 일시 중단 됨 등 저마다의 상태가 있음

**운영체제**는 이런 프로세스의 상태를 **PCB**에 기록하여 관리함 

많은 운영체제는 이처럼 동시에 실행되는 수많은 **프로세스**를 `계층적`으로 관리

### 🔥 프로세스 상태

여러 프로세스들이 빠르게 번갈아가며 실행되는 과정에서 

각각의 프로세스는 여러 상태를 거치며 실행되며 그 상태는 PCB를 통해 인식되고 관리

프로세스 상태 표현 방식 (운영체제마다 차이 있음)

- **생성 상태** *new*
    - 이제 막 **`메모리`**에 적재되어 **`PCB`**를 할당받은 상태
    - 실행할 준비가 되면 준비 상태가 되어 CPU의 할당을 기다림
- **준비 상태** *ready*
    - 당장이라도 CPU를 할당받아 실행할 수 있지만 ,자신의 차례가 아니기에 기다리고 있는 상태
    - 차례가 되면 CPU를 할당받아 실행 상태가 됨 → **디스패치** *dispatch*
- **실행 상태** *running*
    - **`CPU`**를 **할당**받아 실행 중인 상태
    - **타이머 인터럽트**가 발생할 때까지 **할당된 일정 시간** 동안 CPU 사용 가능
    - 할당된 시간이 끝나면 다시 **준비** 상태가 되며, **입출력** 작업 등을 기다려야 한다면 **대기** 상태
- **대기 상태** *blocked*
    - 실행 도중 **`입출력장치`**를 사용하여 입출력 작업이 끝날 때까지(입출력 완료 인터럽트를 받을 때까지) 기다리는 상태
    - 입출력 작업이 완료되면 다시 **준비** 상태
    > 
    > ♻️ 프로세스가 대기 상태가 되는 이유에 입출력 작업만 있는 것은 아님.
    > 일반적으로 **특정 이벤트가 일어나길 기다릴 때** 프로세스는 **대기** 상태가 됨.
    > 다만, 프로세스가 대기 상태가 되는 대부분의 입출력 작업
    
- **종료 상태** *terminated*
    - 프로세스가 종료된 상태
    - **`운영체제`**가 **PCB**와 프로세스가 사용한 **메모리** 정리

- **프로세스 상태 다이어그램** *process state diagram*
    
    ![image](https://github.com/user-attachments/assets/65bab395-e47c-4de0-8f5c-e0066ec528bc)

    

### 프로세스 계층 구조

프로세스는 실행 도중 `시스템 호출`을 통해 다른 **프로세스**를 **생성**할 수 있는데,

이 때 생성을 하는 프로세스를 **부모 프로세스** *parent process* 라고 하며

생성된 프로세스를 **자식 프로세스** *child process* 라고 함

일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 **PPID** *parent PID*를 기록

많은 운영체제들은 컴퓨터가 `부팅될 때 실행되는 최초의 프로세스`가 **자식** 프로세스를 생성하고

생성된 자식 프로세스가 또 다시 **자식** 프로세스를 생성하여 트리 구조를 이루는

**프로세스 계층 구조**로 프로세스들을 관리

- **예)** 사용자가 컴퓨터를 켜고 로그인 창을 통해 성공적으로 로그인해서 bash 셸로 Vim이라는 문서 편집기 프로그램을 실행
    1. 사용자가 컴퓨터를 켠 순간에 생성된 최초 프로세스는 로그인을 담당하는 자식 프로세스를 생성
    2. 로그인 프로세스는 bash 셸 프로세스를 생성
    3. bash 셸 프로세스는 Vim 프로세스를 생성
    
    ![image](https://github.com/user-attachments/assets/d36005de-b477-4659-b80f-03fc22ff13b2)

  
> 
> ♻️ **최초의 프로세스**
> 최초의 프로세스는 유닉스 운영체제에서는 `init`, 리눅스 운영체제에서는 `systemd`, macOS에서는 `launchd` 라고 함
> PID는 항상 `1` 이며, 모든 프로세스 최상단에 있는 부모 프로세스
> `pstree` 명령어로 **프로세스 계층 구조**를 확인할 수 있음

### 프로세스 생성 기법

> 부모 프로세스를 통해 생성된 자식 프로세스들은 **복제와 옷갈아입기**를 통해 실행됨
> 

> **부모 프로세스**는 시스템 호출 **fork**를 통해 **자신의 복사본**을 자식 프로세스로 생성하고,
**만들어진 복사본(자식 프로세스)**은 시스템 호출 **exec**을 통해 자신의 메모리 공간을 다른 프로그램으로 교체
> 
- **`fork`**와 **`exec`**는 `시스템 호출`
- **fork**
    - 자기 자신 프로세스의 **복사본**을 만드는 시스템 호출
    - 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성
    - 자식 프로세스는 부모의 복사본이기 때문에,
    부모 프로세스의 **자원들(메모리 내용, 열린 파일 목록)** 등이 상속됨
        - 다만 **PID값**이나 저장된 **메모리 위치**는 다름
    
- **`fork`**를 통해 복사본이 만들어진 뒤 **자식** 프로세스는 **`exec`**를 통해 **새로운 프로그램**으로 전환
- **exec**
    - 자신의 **메모리** 공간에 **새로운 프로그램**을 덮어쓰는 시스템 호출 → 옷 갈아입기
    - 새로운 프로그램 내용으로 전환
    - **코드** 영역과 **데이터** 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 
    **나머지** 영역은 **초기화**
    
    ![image](https://github.com/user-attachments/assets/542b3c1c-7ab7-4eb7-86ee-da06a4769ddb)

    
    - **예)** 사용자가 bash 셸에서 ls라는 명령어를 침
        - 셸 프로세스는 fork를 통해 자신과 동일한 프로세스를 생성
        - 자식 프로세스(셸의 복제 프로세스)는 exec를 통해 ls 명령어를 실행하기 위한 프로세스로 전환되어 실행
- 부모가 자식 프로세스를 실행하며 **프로세스 계층 구조**를 이루는 과정
= `fork`와 `exec`가 반복되는 과정
- **if)** 부모가 `fork` 후 부모, 자식 누구도 `exec` 를 호출하지 않는다면
부모 프로세스와 동일한 코드를 병행하여 실행하는 프로세스가 됨
- 예제 코드
    
    https://github.com/kangtegong/self-learning-cs/blob/main/process/process_cplusplus.md
    
<br>


## 10-3. 스레드

> `스레드`   `멀티프로세스`   `멀티스레드`
> 
- **스레드** *thread*
    - **프로세스**를 구성하는 **실행의 흐름 단위**
    - **하나**의 `프로세스`는 **여러 개**의 `스레드`를 가질 수 있음
    - 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있음
    
    ![image](https://github.com/user-attachments/assets/0846217f-91d3-4325-8c14-ab9b034016de)

    

### 프로세스와 스레드

전통적 관점에서 하나의 프로세스는 하나의 일만 처리

`프로세스`가 **하나의 실행 흐름**을 가지고 한 번에 한 부분만 실행됨 = **단일 스레드 프로세스**

![image](https://github.com/user-attachments/assets/26e5307f-7807-4ed7-87a5-5af44b16722a)


`스레드`라는 개념이 도입되며 하나의 프로세스가 **여러 일을 동시에 처리**할 수 있게 됨

프로세스를 구성하는 **여러 명령어를 동시에 실행**할 수 있게 됨

![image](https://github.com/user-attachments/assets/67252217-05e6-46a8-95f8-3aab2db6e7ba)


- **스레드**
    - 프로세스를 구성하는 **실행** 단위
    - 하나의 프로세스 내에서 각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터 값, 스택으로 구성
        - ✅ 각자 PC를 비롯한 레지스터 값, 스택을 가지고 있기 때문에 **스레드마다 각기 다른 코드 실행 가능**
        
        ![image](https://github.com/user-attachments/assets/153bb752-f373-4138-a59d-ca4752fa3a08)

        
    - ✅ 프로세스의 `스레드`들은 실행에 필요한 최소한의 정보(레지스터, 스택)만을 유지한 채 **`프로세스 자원`(코드/데이터/힙 영역)을 `공유`**하면서 실행

> `프로세스`가 **실행되는 프로그램**이라면 `스레드`는 **프로세스**를 구성하는 **실행의 흐름 단위**
최근 많은 `운영체제`는 CPU가 처리할 작업을 전달할 때 프로세스가 아닌 **스레드 단위로 전달**
`스레드`는 프로세스 자원을 공유한 채 실행에 필요한 최소한의 정보만으로 실행
> 


> ### ♻️  리눅스 운영체제에서의 프로세스 vs 스레드
> 
> 많은 운영체제가 프로세스와 스레드를 구분하지만, 리눅스와 일부 운영체제는 구분하지 않음.
> 리눅스는 프로세스와 스레드 모두 실행의 문맥(context of execution)이라는 점에서 동등하다고 간주
>  → **`태스크(task)`**라는 이름으로 통일
> 
> 리눅스 운영체제 창시자 - 리누스 토르발스(Linus Torvalds)의 글

### 멀티프로세스와 멀티스레드

기존의 한 번에 하나의 일만 처리하는 프로세스는 **단일 스레드 프로세스**

- **멀티 프로세스** *multi-process*
    - 여러 프로세스를 동시에 실행하는 것
    - 기본적으로 프로세스끼리 **자원을 공유 X → 메모리 낭비**
    - 하나에 문제가 생겨도 서로에게 영향력이 적다
    - IPC, 공유 메모리 등으로 통신은 가능하지만 오버헤드 존재
- **멀티 스레드** *multi-thread*
    - 프로세스 내에 여러 스레드를 동시에 실행하는 것
    - 같은 프로세스 내의 스레드끼리 프로세스 자원을 공유
    - 여러 프로세스를 병행 실행하는 것보다 **메모리를 더 효율적**으로 사용 가능
    - **협력과 통신에 유리**

> ♻️ **동일한 작업을 수행하는 단일 스레드 프로세스 여러 개를 실행하는 것과 
하나의 프로세스를 여러 스레드로 실행하는 것은 무엇이 다를까?**
>  
> “hello, os”를 화면에 출력하는 간단한 프로그램
>  
> ![image](https://github.com/user-attachments/assets/82fb3c08-9330-4170-aad4-f6664ec44a6f)
>   
> 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유함
> `프로세스`를 fork하여 같은 작업을 하는 동일한 프로세스 두 개를 동시에 실행하면 코드, 데이터, 힙 등을 비롯한 모든 자원이 복제되어 메모리에 적재
> (PID, 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 **통째로 메모리에 적재**)
>  
> 어찌 보면 같은 프로그램을 실행하기 위해 메모리에 동일한 내용들이 **중복해서 존재** → **낭비**
>  
> ![image](https://github.com/user-attachments/assets/a4f783a2-0e41-41af-a567-723303e18fbf)
>   
> fork를 한 직후 같은 프로세스를 통째로 메모리에 중복 저장하지 않으면서 동시에 프로세스끼리 자원을 공유하지 않는 방법도 있음
>  → **`쓰기 시 복사(copy on write)`**기법
> 
>  
> `스레드`들은 각기 다른 스레드 ID, 레지스터 값, 스택을 가질 뿐 프로세스가 가지고 있는 자원(코드/데이터/힙) 영역을 공유
> **메모리 효율적** → 자원을 공유하기 때문에 서로 **협력과 통신에 유리**
>  
> ![image](https://github.com/user-attachments/assets/2093bc98-4dd6-401a-8ceb-e1365d6b7335)
>   
> 프로세스의 자원을 공유한다는 특성은 때론 단점이 되기도 함
> 멀티프로세스 환경에서는 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 적거나 없지만,
> 멀티스레드 환경에서는 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음
> 모든 스레드는 프로세스의 자원을 공유하고, 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 받기 때문
> ![image](https://github.com/user-attachments/assets/eb880604-84c8-46c2-ba51-d5e1b1f41281)


> ✅ ### **프로세스 간 통신**  
> 프로세스끼리는 ‘기본적으로’ 자원을 공유하지 않지만, 충분히 가능  
> 프로세스 간의 자원을 공유하고 데이터를 주고 받는 것을 **`프로세스 간 통신(IPC; Inter-Process Communication)`**  
> ‘`통신`’ - 네트워크로 데이터를 주고 받음 X, 같은 컴퓨터 내의 서로 다른 프로세스나 스레드끼리 데이터를 주고 받는 것  
> **예)** 프로세스 A ‘hello.txt’에 쓰기, 프로세스 B ‘hello.txt’ 읽기 → **`파일을 통한 프로세스 간 통신`**  
> 프로세스 간 공유하는 메모리 영역을 통해 데이터 주고 받기 → **`공유 메모리(shared memory)`**  
>  **예)** 전역 변수  
> 이 외 프로세스들은 **소켓, 파이프**를 통해 통신   
