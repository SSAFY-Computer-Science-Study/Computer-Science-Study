# Chapter 11. CPU 스케줄링

## 11-1. CPU 스케줄링 개요

### 프로세스 우선순위

---

- CPU 스케줄링
  - 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
  - 컴퓨터 성능과도 직결됨

프로세스마다 우선순위가 다르다. 대표적으로 우선순위가 높은 프로세스는 입출력 작업이 많은 프로세스다. 입출력 작업이 많은 프로세스를 먼저 실행하는 게 왜 더 효율적일까?

- 프로세스의 과정
  - 대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행된다.
  - 프로세스는 실행 상태와 대기 상태를 반복하며 실행된다.

![Image](https://github.com/user-attachments/assets/cbd41a85-e956-43b7-8263-1d6281369dfa)

프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다.

- 입출력 집중 프로세스
  - 실행 상태보다는 대기 상태에 더 많이 머무르게 됨
- CPU 집중 프로세스
  - 대기 상태보다는 실행 상태에 더 많이 머무르게 됨

> 💡**CPU 버스트와 입출력 버스트**
>
> - CPU 버스트
>   - CPU를 이용하는 작업
> - 입출력 버스트
>   - 입출력 장치를 기다리는 작업
>
> 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행한다.
>
> ![Image](https://github.com/user-attachments/assets/f4b6ea6c-a56d-4269-8982-0dc05a5302e5)

> **CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원 요구했을 경우**
>
> - 입출력 장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 얼른 먼저 처리해버리면 다른 프로세스가 cpu를 사용할 수 있다.
>
> ![Image](https://github.com/user-attachments/assets/490930dc-af46-4199-a698-d2f578a6cb40)
>
> 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다 `각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적`이다.

- 우선순위
  - 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위를 부여함
  - PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.
  - 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행된다.

> 💡ps -el 명령어를 통해 유닉스 체계 운영체제에서 일부 프로세스의 우선순위를 변경할 수도 있다.

### 스케줄링 큐

---

매번 모든 PCB를 검사하여 먼저 자원을 이용할 프로세스를 결정하는 일은 매우 번거롭고 시간이 오래 걸리는 일이다.

그래서 운영체제는 프로세스들에 ‘줄을 서서 기다릴 것’을 요구한다. 그리고 운영체제는 이 줄을 `스케줄링 큐`로 구현하고 관리한다.

- 반드시 선입선출 방식일 필요는 없다

대부분의 자원은 이렇듯 큐로 관리된다. 대표적으로는 준비 큐와 대기큐가 있다.

- `준비 큐`
  - CPU를 이용하고 싶은 프로세스들이 서는 줄
- `대기 큐`
  - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미함
  ![Image](https://github.com/user-attachments/assets/3ece2921-9f44-4745-9f2c-93fd631e55ea)

### 선점형과 비선점형 스케줄링

---

프로세스가 CPU를 사용하고 있는 와중, 갑자기 다른 급한 프로세스가 CPU를 지금 당장 사용하길 요청한다면?

- 선점형 스케줄링
  - 다른 프로세스가 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에게 할당할 수 있는 스케줄링 방식
  - 정해진 시간만큼 CPU를 사용하고, 모두 소비하면 `타이머 인터럽트`가 발생하여 다른 프로세스에게 자원을 할당하는 방식 → `선점형`!
  - 현재 대부분의 운영체제게 차용하고 있는 방식
- 비선점형 스케줄링
  - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식
  - 독점할 수 있는 스케줄링 방식
- 장단점
  - 선점형 스케줄링
    - 장점 : 어느 한 프로세스의 자원 독점을 막고 골고루 자원 배분 가능
    - 단점 : 문맥 교환 과정에서 오버헤드 발생 가능
  - 비선점형 스케줄링
    - 장점 : 문맥 교환의 횟수가 비교적 적어 오버헤드는 선점형 스케줄링보다 적음
    - 단점 : 하나의 프로세스가 자원 사용 중이라면 무작정 기다려야 함

## 11-2. CPU 스케줄링 알고리즘

### 스케줄링 알고리즘의 종류

---

### 선입 선처리 스케줄링 (FCFS)

---

- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 `비선점형` 스케줄링 방식
- 공정해보이지만, 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있음
  - 무작정 기다리는 프로세스 생길 수 있음
  - 호위 효과 : CPU 스케줄링 알고리즘에서 실행시간이 긴 프로세스가 우선적으로 처리되면서, 짧은 프로세스가 대기하는 현상

![Image](https://github.com/user-attachments/assets/a0114cf9-8142-466b-baa0-027c6d738698)

### 최단 작업 우선 스케줄링 (SJF)

---

- 호위효과를 방지하려면?
  - CPU 시간이 긴 프로세스는 나중에 실행하고, 사용시간이 짧은 간단한 프로세스를 먼저 실행하면 됨

![Image](https://github.com/user-attachments/assets/d167517b-5c88-4d93-b7b7-92ce3c4a2a52)

- 이를 `최단 작업 우선 스케줄링` 혹은 `SJF 스케줄링`이라 부름
- `비선점형` 스케줄링 알고리즘
  - but, 선점형으로 구현될 수도 있음

### 라운드 로빈 스케줄링 (RR)

---

- 라운드 로빈 스케줄링
  - `선입 선처리 스케줄링 + 타임 슬라이스`
  - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 `선점형` 스케줄링
- 타임 슬라이스
  - 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
  - 타임 슬라이스 크기가 매우 중요함
    - 매우 크다면 → 선입 선처리랑 다를게 없음
    - 매우 작다면 → 문맥교환 비용 커짐

![Image](https://github.com/user-attachments/assets/d167517b-5c88-4d93-b7b7-92ce3c4a2a52)

### 최소 잔여 시간 우선 스케줄링 (SRT)

---

- SRT 스케줄링이라고도 불림
- `최단 작업 우선 스케줄링 (SJT) + 라운드 로빈 (RR)`
  - SJT에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 `남아있는 작업 시간이 가장 적은 프로세스`를 선택함

### 우선순위 스케줄링 (Priority)

---

- 프로세스들에 우선순위를 부여함
- 가장 높은 우선순위를 가진 프로세스부터 실행하는 알고리즘
- 근본적으로 `기아 현상`이라는 문제가 있음
  - 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기될 수 있음
  - 이를 막기 위해 `에이징` 기법이 있음
  - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

![Image](https://github.com/user-attachments/assets/9970b54d-6c9d-4a51-b7a2-0336c6964ffc)

### 다단계 큐 스케줄링 (Multilevel queue)

---

- 우선순위별로 준비 큐를 여러 개 사용하는 방식
- 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선 순위 큐에 있는 프로세스들을 처리함
- 큐마다 다른 타임 슬라이스와 스케줄링 알고리즘을 사용할 수 있음

![Image](https://github.com/user-attachments/assets/0f70a5d8-858a-473c-9a4c-c88c70374166)

### 다단계 피드백 큐 스케줄링 (Multilevel feedback queue)

---

- 다단계 큐 스케줄링의 발전된 형태
- 프로세스들이 큐 사이를 이동할 수 없다
  → 우선순위가 낮은 프로세스는 계속 연기될 여지가 있음
  → 기아 현상 가능
- `프로세스들이 큐 사이를 이동할 수 있다!!`
  - 새로 준비된 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 샐행됨

![Image](https://github.com/user-attachments/assets/66c1ff8d-7439-4d40-a451-6746a8c6318b)

- 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다며 다음 우선순위 큐에 삽입되어 실행된다. 이 과정이 반복되고 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다.
- 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 `에이징` 기법을 적용하여 기아 현상을 예방할 수 있다.

![Image](https://github.com/user-attachments/assets/f3cf14c2-2ba4-44fb-9e63-48f83c777f3a)

- 가장 일반적인 CPU 스케줄링 알고리즘
