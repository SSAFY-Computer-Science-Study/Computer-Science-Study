# Chapter 05. CPU 성능 향상 기법


## 05-1. 빠른 CPU를 위한 설계 기법

### 클럭

---

> 💡 컴퓨터 부품들은 `클럭 신호`에 맞춰 일사불란하게 움직인다.
> CPU는 `명령어 사이클`이라는 정해진 흐름에 맞춰 명령어들을 실행한다.

- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋다.
- 클럭 속도
    - 헤르츠(Hz) 단위로 측정됨
    - 1초에 클럭이 몇 번 반복되는지 나타냄

> 💡 클럭 속도가 매번 일정하게 유지되지는 않는다.
> 고성능을 요구하는 순간에 순간적으로 속도를 높이고, 그렇지 않을 때는 속도를 낮추기도 한다.
> 최대 클럭 속도를 강제로 더 끌어올리는 기법을 `오버클럭킹`이라고 한다.


### 코어와 멀티코어

---

Q. CPU의 성능을 높이려면?

A. CPU의 코어와 스레드 수를 늘리는 방법이 있다.

- CPU
    - CPU 내부에는 `명령어를 실행하는 부품`이 있음
    - 이를 `코어`라고 부름
    - `명령어를 실행하는 부품` → `명령어를 실행하는 부품을 여러 개 포함하는 부품`으로 발전
    

![image.png](https://github.com/user-attachments/assets/1a804e1d-1688-4525-809c-9cc6cc87d4f2)

- `멀티 코어 CPU` or `멀티코어 프로세서`
    - 코어를 여러 개 포함하고 있는 CPU
    - CPU 내에 명령어를 처리하는 일꾼이 여러 명 있는 것과 같음
    - CPU 의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않음
    - 코어마다 처리할 명령어들을 얼마나 적절하게 분배하는 게 중요함

### 스레드와 멀티 스레드

---

- 스레드
    - `실행 흐름의 단위`
    - 하드웨어적 스레드와 소프트웨어적 스레드로 나뉨
- 하드웨어적 스레드
    - 하나의 코어가 동시에 처리하는 명령어 단위
    - 2코어 4스레드 CPU
        - 명령어를 실행하는 부품이 2개이고, 한 번에 4개의 명령어를 처리할 수 있음
    
    ![image.png](https://github.com/user-attachments/assets/3c7fcfce-69ae-42a0-ad20-3d7608a7d40f)
    
    - `멀티스레드 프로세서` or `멀티스레드 CPU`
    - 하이퍼스레딩 (= 인텔의 멀티스레드 기술)
- 소프트웨어적 스레드
    - 하나의 프로그램에서 독립적으로 실행하는 단위
    - 보통 운영체제에서 배우는 스레드를 의미함
    - 하나의 프로그램은 실행 과정에서 한 부분만 실행될 수도 있지만, 여러 부분이 동시에 실행될 수도 있음
    
    ![image.png](https://github.com/user-attachments/assets/d7429c39-bdd4-4134-8f6d-40132dba4c22)
    

### 멀티스레드 프로세서

---

하드웨어적 스레드 살펴보기

- 멀티스레드 프로세서
    - 가장 큰 핵심은 `레지스터`
    - 여러 명령어를 동시에 처리하도록 하려면 꼭 필요한 레지스터를 여러 개 가지고 있으면 됨
    - 아래 레지스터 세트가 두 개인 CPU는 하나의 코어에서 두 개의 명령어를 동시에 실행함
    
    ![image.png](https://github.com/user-attachments/assets/33c26466-de3c-4991-80f2-39c99d1bc1dd)
    
    - 프로그램 입장에서는 한 번에 하나의 명령어를 처리하는 CPU 가 네 개 있는 것처럼 보임
        - 하드웨어 스레드를 `논리 프로세서`라고 부르기도 함
    
    ![image.png](https://github.com/user-attachments/assets/e4969538-ff32-4be9-9963-fe42474145dd)
    

> 💡 `코어` : 명령어를 실행할 수 있는 ' 하드웨어 부품'<br>
> `스레드` : 명령어를 실행하는 단위<br>
> `멀티코어 프로세서` : 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU<br>
> `멀티스레드 프로세서` : 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

## 05-2. 명령어 병렬 처리 기법

- `명령어 병렬 처리 기법`
    - 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법
    - 대표적인 기법 : 명령어 파이프라이닝 , 슈퍼스칼라 , 비순차적 명령어 처리

### 1. 명령어 파이프라인

---

- 명령어 파이프라인
    - 공장 생산 라인과 같이 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법

하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누기
① 명령어 인출(Instruction Fetch)
② 명령어 해석(Instruction Decode)
③ 명령어 실행(Execute Instruction)
④ 결과 저장 (Write Back)

단계가 겹치지만 않는다면 CPU는 `각 단계를 동시에 실행할 수 있다.`

ex) CPU는 한 명령어를 `인출`하는 동안에 다른 명령어를 `실행`할 수 있고, 한 명령어
가 `실행`되는 동안에 연산 결과를 `저장`할 수 있음

![image.png](https://github.com/user-attachments/assets/6a37fd63-3021-45c5-8f89-2fea5fedeeb1)

### 파이프라이닝 위험

- 특정 상황에서는 성능 향상에 실패하는 경우도 있음
- 크게 데이터 위험 , 제어 위험 , 구조적 위험이 있음

![image.png](https://github.com/user-attachments/assets/86aa7c03-af44-43c6-a4a6-28e09cd6602a)

- 데이터 위험
    - 명령어 간 `데이터 의존성`에 의해 발생
    - 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있음
    - 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 상황
- 제어 위험
    - 주로 분기 등으로 인한 `프로그램 카운터의 갑작스러운 변화`에 의해 발생
    - 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어짐
    - 이를 위해 사용하는 기술 중 하나가 `분기 예측`
        - 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술
    
    ![image.png](https://github.com/user-attachments/assets/7674d185-8e9b-4524-b2b1-1a337f7153e3)
    
- 구조적 위험
- 명령어들을 겹쳐 실행하는 과정에서 `서로 다른` 명령어가 동시에 ALU, 레지스터 등과 `같은 CPU 부품을 사용`하려고 할 때 발생

### 2. 슈퍼스칼라

---

- 슈퍼스칼라
    - CPU 내부에 `여러 개의 명령어 파이프라인을 포함`한 구조
    - 오늘날 대부분의 CPU 에서는 여러 개의 파이프라인을 이용함
    - 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 함
    - 슈퍼스칼라 프로세서는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빠르지만, 파이프라인 위험 등의 예상치 못한 문제가 있음
        - 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 잘 설계되어야 함
    
    ![image.png](https://github.com/user-attachments/assets/6621c677-4f55-4381-a617-afbafffc1afe)
    

### 3. 비순차적 명령어 처리

---

- 비순차적 명령어 처리
    - `O0OE` 로 줄여 부름
    - 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법이
    - 명령어들을 순차적으로 실행하지 않는 기법으로, `명령어의 합법적인 새치기` 라고 볼 수 있음

모든 명령어를 순차적으로만 처리한다면 이런 예상치 못한 상황에서 명령어 파이프라인은 멈춰
버리게 된다. 명령어를 순차적으로만 실행하지 않고 `순서를 바꿔 실행해도 무방한 명령어`를 먼저 실행하여 명령어 `파이프라인이 멈추는 것을 방지하는 기법`을 비순차적 명령어 처리 기법이다.

## 05-3. CISC와 RISC

Q. 파이프라이닝 하기 쉬운 명령어란 무엇일까? 명령어가 어떻게 생겨야 파이프라이닝에 유리할까?

A. CPU의 언어인 ISA와 각기 다른 성격의 ISA를 기반으로 설계된 CISC 와 RISC를 살펴보자.

### 명령어 집합

---

- 명령어 집합 or 명령어 집합 구조 (`ISA`)
    - CPU가 이해할 수 있는 명령어들의 모음
    - CPU 마다 ISA가 다를 수 있음
        - 명령어의 세세한 생김새 , 명령어로 할 수 있는 연산 , 주소 지정 방식 등은 CPU 마다 조
        금씩 차이가 있음

> 💡 - ISA가 다르다 == CPU가 이해할 수 있는 명령어가 다르다 == 명령어가 달라지면 어셈블리어도 달라진다.
> - 같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA 가 다르면 CPU 가 이해할 수 있는 명령어도 어셈블리어도 달라진다.
> ![image.png](https://github.com/user-attachments/assets/a07e8ed5-690b-40ae-b25a-08f3e47aa8c8)


> 💡 - ISA가 같으면
>    - 같은 CPU들끼리는 서로의 명령어를 이해할 수 있음
> - ISA 가 다르면
>    - 서로의 명령어를 이해하지 못함
>        - ISA 는 일종의 CPU의 언어인 셈
>    - ISA는 `CPU의 언어`임과 동시에 `CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속`이라고도 볼 수 있음

Q.명령어 병렬 처리 기법들을 도입하기 유리한 ISA는 무엇일까?

A. 이와 관련해 현대 ISA의 양대 산맥인 CISC와 RISC 에 대해 알아보자.

### CISC

---

- CISC
    - Complex Instruction Set Computer
    - `복잡한 명령어 집합을 활용하는 CPU 설계 방식`
    - 명령어의 형태와 크기가 다양한 `가변 길이 명령어`를 활용함
    - 상대적으로 `적은 수의 명령어`로도 프로그램을 실행할 수 있음
        - 메모리 효율성 측면에서 좋음
    - x86, x86-64
- 단점
    - 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
    - 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 함
        - 명령어의 규격화가 어려움
    
    ![image.png](https://github.com/user-attachments/assets/ab8c028b-1f96-4cf4-ad49-bd616327cd8b)
    
    - 명령어 집합이 다양하고 복잡한 기능을 지원하지만 실제로는 자주 사용되는 명령어만 쓰임

> 💡 ### CISC의 한계가 우리들에게 준 교훈
> ① 빠른 처리를 위해 명령어 파이프라인을 활용해야 한다.
> 원활한 파이프라이닝을 위해 `명령어 길이와 수행 시간이 짧고 규격화`되어 있어야 한다.
> ②  자주 쓰이는 명령어만 줄곧 사용된다.
> 복잡한 기능을 지원하는 명령어를 추가하기보다는 `자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것`이 중요하다.

### RISC

---

- RISC
    - CISC의 한계를 극복하여 등장함
    - CISC 에 비해 명령어의 종류가 적음
    - CISC 와는 달리 짧고 `규격화`된 명령어, 되도록 1 클럭 내외로 실행되는 명령어를 지향
    - `고정 길이 명령어`를 활용함
    - 메모리에 직접 접근하는 명령어를 `load`, `store` 두 개로 제한할 만큼 메모리 접근을
    단순화하고 최소화를 추구함
        - 메모리 접근을 단순화, 최소화하는 대신 `레지스터를 적극적으로 활용`
    - CISC 보다 레지스터를 이용하는 연산이 많고, 범용 레지스터 개수도 더 많음
    - 사용 가능한 명령어 개수가 CISC보다 적기 때문에 RISC는 보다 많은 명령으로 프로
    그램을 작동시킴
- ARM

![image.png](https://github.com/user-attachments/assets/8426d59a-929b-4c65-8bc8-6e4d5e5bfaf6)