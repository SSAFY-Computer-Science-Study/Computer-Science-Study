# Chapter 13. 교착상태

![image](https://github.com/user-attachments/assets/0be28fb5-f2d7-4016-a28e-68b10f985940)


---

## 13-1. 교착상태란

### 식사하는 철학자 문제

---

- 식사하는 철학자 문제
  - 동그란 원탁에 다섯 명의 철학자가 앉아있음
    ![image](https://github.com/user-attachments/assets/29ff9e62-58fb-4c28-9c99-d13212c71986)

- 모든 철학자가 동시에 포크르 집어 식사를 한다면?
  - 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생할 수 있음
  - 모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없음
  - = 모든 철학자가 다른 철학자가 포크를 내려놓을 때까지 기다림
    → `교착상태`

### 자원 비유

- 철학자 = 프로세스 혹은 스레드
- 포크 = 자원
  - 포크는 한 번에 한 명의 철학자가 사용 가능(=하나의 프로세스 혹은 스레드만 접근 가능)
  - `임계구역`
- 생각하는 행위 = 자원을 기다리는 것

![image](https://github.com/user-attachments/assets/c55c48e8-478f-4b32-b881-e03ee1e754d0)


## 교창 상태 예시

- 뮤택스 락에서도 교착 상태 발생 가능
- 프로세스 A는 lock1 을 잠그고, 프로세스 B는 lock2를 잠근 상태에서, 프로세스 A가 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false되길 기다리는 상황

![**스핀락**
코드가 실행된다는 것 == CPU 할당 받은 것!!!](https://github.com/user-attachments/assets/00f25e2a-9768-4ef6-82e6-0f53a109e380)



### 자원 할당 그래프

---

- 자원 할당 그래프
  - 어떤 프로세스가 어떤 자원을 사용하고 있고, 또 어떤 프로세스가 어떤 자원을 기다리고 있는지를 표현하는 간단한 그래프

### 첫째, 프로세스는 원으로, 자원의 종류는 사각형으로 표현한다.

---

![image](https://github.com/user-attachments/assets/10e6d8bf-c5cd-4fe9-aba1-51407e6c1d3a)


### 둘째, 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현한다.

---

- 같은 자원이라 할지라도 사용 가능한 자원의 개수는 여러 개 있을 수 있다.
- ex) 하드 디스크가 세 개 있는 경우
  - 하드 디스크 종류는 하나
  - 사용 가능한 하드 디스크 개수는 세 개
  - 따라서 사각형 안에 세 개의 점으로 표현
- ex) CPU가 두 개 있는 경우
  - CPU 종류는 하나
  - 사용 가능한 CPU 개수는 두 개
  - 따라서 사각형 안에 두 개의 점으로 표현

![image](https://github.com/user-attachments/assets/6a391320-7ae7-49da-a6d7-220975408a98)


### 셋째, 프로세스가 어떤 `자원을 할당받아 사용 중`이라면 `자원에서 프로세스를 향해 화살표`를 표시한다.

---

프로세스가 자원 이용을 끝내고 운영체제에 자원을 반납하면 화살표는 삭제된다.

![image](https://github.com/user-attachments/assets/918f16e0-e619-4778-bb1a-391d39ba334d)


### 넷째, 프로세스가 어떤 `자원을 기다`리고 있다면 `프로세스에서 자원으로 화살표`를 표시한다.

---

`프로세스 D가 CPU의 할당을 기다리고 있음`을 나타낸 그래프이다.

![image](https://github.com/user-attachments/assets/0ea8979c-e9a7-4b85-bb65-86930a2f9bf8)


## 교착상태의 자원 할당 그래프

---

![image](https://github.com/user-attachments/assets/141468fc-b568-45c6-a375-50f39169b8c7)


![image](https://github.com/user-attachments/assets/2a667fb5-64fc-4b23-8b7f-fd1884f655af)


### 교착 상태 발생 조건

---

교착상태 발생할 조건 4가지

- 상호 배제
- 점유와 대기
- 비선점
- 원형 대기

4개의 조건 중 `하나라도 만족하지 않는다면 교착 상태가 발생하지 않지만`, 아래 조건이 모두 만족될 때 교착 상태가 `발생할 가능성이 생긴다`고 보면 된다.

### 상호 배제

---

교착 상태가 발생한 근본적인 원인

- 해당 자원을 한 번에 하나의 프로세스만 이용했기 때문
- 만일 식사하는 철학자 문제에서 하나의 포크를 여러 명이 동시에 사용할 수 있었다면 교착 상태는 발생하지 않았을 것
- `한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때`, 즉 `상호 배제` 상항에서 교착 상태 발생 가능

### 점유와 대기

---

- 또 다른 이유
  - `왼쪽 포크를 들고 다른 철학자의 포크`를 기다렸기 때문
  - 다시 말해 자원을 보유한 채 다른 자원을 기다렸기 때문에 문제가 발생한 것
  - 자원을 할당 받은 상태에서 다른 자원을 할당받기를 기다리는 상태를 `점유와 대기`라고 함

### 비선점

---

- 만일 철학자들 중 누군가가 다른 철학자의 포크를 강제로 빼앗을 수 있었다면 교착 상태 발생 안 했을 것
- 근본적인 문제는 프로세스가 `자원을 비선점`하고 있었기 때문
- 그 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용할 수 있음
- 즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 발생한 것

### 원형 대기

---

- 또 다른 이유는 프로세스들과 프로세스가 `요청 및 할당받은 자원이 원의 형태를 이루었기` 때문
- 원의 형태로 그려지만 교착 상태가 발생할 `수` 있음 (꼭 발생하는 건 아님)
- 이렇게 프로세스들이 원의 형태로 자원을 대기하는 것을 `원형 대기`라고 함

## 13-2. 교착 상태 해결 방법

운영체제는 교착상태를 어떻게 해결할까?

크게 세 가지 방법이 있다. 예방, 회피, 검출 후 회복이다.

1. 예방 : 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착 상태 예방
2. 회피 : 교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식
3. 검출 : 자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복하는 방법

### 교착 상태 예방

---

> 예방
>
> - 프로세스들에 자원을 할당할 때 상호 배제, 점유와 대기, 비선점, 원형 대기 중 `하나의 조건이라도 만족시키지 않게 할당하면 교착 상태는 발생하지 않음`

### 자원의 상호 배제를 없애보자

---

= 모든 자원을 공유 가능하게 만든다

다만 이 방식대로라면 이론적으로는 교착 상태를 없앨 수는 있지마, 현실적으로 모든 자원의 상호 배제를 없애기는 어려우므로 현실적으로 어렵다.

![image](https://github.com/user-attachments/assets/1856f775-145d-487a-9e5b-8bbf3859b0f4)


## 점유와 대기를 없애보자

---

= 철학자들에게 한 손에 포크를 들고 다른 포크를 기다리지 못하게 금지하는 것

= 포크를 두 개 동시에 들거나, 아니면 아예 들지 못하게 하는 것

= 운영체제는 특정 프로세스에게 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분

이렇게 하면 `자원의 활용률이 낮아질` 우려가 있다. 게다가 이렇게 하면 많은 자원을 사용하는 프로세스가 불리해진다. 자원을 많이 사용하는 프로세스는 `자원을 사용할 타이밍을 확보하기가 어렵기` 때문이다. 무한정 기다리게 되는 `기아 현상`을 야기할 수도 있다.

### 비선점 조건을 없애보자

---

= 철학자의 포크를 빼앗는 것

= 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있음

이 방식은 일부 자원에 대해서 효과적이다.

- CPU가 프로세스들이 선점할 수 있는 대표적인 자원

하지만 모든 자원이 이렇게 선점 가능한 것은 아니다. 한 프로세스의 작업이 끝날 때까지 다른 프로세스가 기다려야 하는 자원도 얼마든지 있다. 이는 다소 범용성이 떨어지는 방안이다.

### 원형 대기 조건을 없애보자

---

이는 간단하다. 모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형 대기는 발생하지 않는다.

예를 들어, 식사하는 철학자 문제에서 모든 포크에 1번부터 5번까지 번호를 붙이고, 철학자들에게 번호가 낮은 포크에서 높은 포크 순으로 집어들게 한다면 원형 대기는 발생하지 않는다.

- 5번 포크를 집어들고 1번 포크를 집어들 수 없기 때문!!

![image](https://github.com/user-attachments/assets/22374f05-4041-400b-8101-6d689e5bb197)


= 이는 마치 철학자들이 원형 식탁이 아닌 사각형 식탁에서 일렬로 앉아 식사하는 상황과 유사하다.

하지만 모든 컴퓨터 시스템 내에 존재하는 `수많은 자원에 번호를 붙이는 일은 그리 간단한 작업이 아니`고, 각 자원에 어떤 번호를 붙이는지에 따라 `특정 자원의 활용률이 떨어질 수` 있다.

### 교착 상태 회피

---

교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식이다.

`교착 상태 회피` 방식에서 `교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제`로 간주한다.

- ex) 포크가 100, 1000개 있는 상황일 때 철학자가 포크 1, 2개 요청한다면 교착 상태 발생 안함

그렇기 때문에 프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도의 양만큼 자원을 배분한다.

### 용어

1. 안전 상태
   - 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태
2. 불안전 상태
   - 교착 상태가 발생할 수도 있는 상황
   - `안전 순서열이 없는 상황`
3. 안전 순서열
   - 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미함
   - ex) `웹 브라우저-메모장-게임 프로세스` 순서대로 자원 할당할 때 교착 상태가 발생하지 않는다면 `웹 브라우저→메모장→게임`이 안전 순서열이 됨
   - `안전 순서열이 있는 상태`를 `안전 상태`라고 함

## 안전 상태와 불안전 상태, 안전 순서열

---

### 안전 상태

![image](https://github.com/user-attachments/assets/0afeaa3e-35ba-479d-96f4-052e14ff82d3)

![image](https://github.com/user-attachments/assets/b8899c5a-c515-4cba-a891-a25f6c2d3de7)


![image](https://github.com/user-attachments/assets/2bce3c44-ec18-485e-ae7b-8c477814eced)


![image](https://github.com/user-attachments/assets/b32ff867-b7d6-4af8-8573-1666af29b431)


즉, `P2 → P1 → P3` 라는 안전 순서열대로 자원을 배분하면 P1, P2, P3 모두 자원을 할당받고 교착 상태 없이 올바르게 작업을 마칠 수 있다.

### 불안전 상태

![image](https://github.com/user-attachments/assets/1633aa68-d660-4373-a4bc-7e5e56a959f3)


![image](https://github.com/user-attachments/assets/a2ef112c-6df2-4c3c-8f26-b12bf0dd88d2)


![image](https://github.com/user-attachments/assets/373d0876-7584-44da-8c87-6de3516db888)


즉, 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 `안전 상태에서 안전 상태로 움직이는 경우에만` 자원을 할당하면 된다. 즉, 교착 상태 회피 방식은 `항시 안전 상태를 유지하도록 자원을 할당하는 방식`이다.

### 교착 상태 검출 후 회복

---

이는 교착 상태 발생을 인정하고 사후에 조치하는 방식읻. 검출 후 회복 방식에서 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사한다. 그리고 교착 상태가 검출되면 다음과 같은 방식으로 회복한다.

### 선점을 통한 회복

---

- 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식이다. 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식이다.

### 프로세스 강제 종료를 통한 회복

---

- 가장 단순하면서 확실한 방식이다. 운영체제는 교착 상태에 놓인 프로세스를 모두 강제 종료할 수도 있고, 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료할 수도 있다.
- 전자는 확실하지만 그만큼 많은 프로세스들이 작업 내역을 잃게 될 가능성이 있고, 후자는 작업 내역을 잃는 프로세스는 최대한 줄일 수 있지만 교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드를 야기한다.

사실은 `교착 상태를 아예 무시하는 방법`도 있다. 드물게 발생하는 잠재적인 문제를 무시로 대처하는 방식이다. 이는 `타조 알고리즘`이라 불린다. 때때로 이 방식이 적합할 때도 많다.

![image](https://github.com/user-attachments/assets/46d8c2e0-a92b-46cc-ad44-e3990e253b03)
