# Chapter 06. 메모리와 캐시 메모리

- `RAM(Random Access Memory)` : 프로그램이 실행되는 동안 저장 / 휘발성
- `ROM(Read Only Memotry)` : 읽기 전용 메모리 / 비휘발성

## 06-1. RAM의 특징과 종류

### RAM의 특징

---

- 휘발성 저장 장치
- 전원을 끄면 저장된 내용이 사라짐
    - RAM
- 비휘발성 저장 장치
- 전원이 꺼져도 저장된 내용이 유지됨
    - 하드 디스크, SSD, CD-ROM, USB 메모리와 같은 `보조기억장치`

> 💡 CPU는 보조기억장치에 직접 접근하지 못한다.
> - 그래서 일반적으로 보조기억장치인 `비휘발성 저장 장치`에는 `보관할 대상`을 저장하고,
> - `휘발성 저장장치`인 `RAM` 에는 `실행할 대상`을 저장한다.
> - CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면 이를 RAM 으로 복사하여 저장한 뒤 실행한다.
> ![image.png](https://github.com/user-attachments/assets/a692f8b3-2b60-4cca-b08d-faa1b581ad06)


### RAM의 용량과 성능

---

- RAM 용량이 적다면?
    - 보조기억장치에서 실행할 프로그램을 가져오는 일이 잦아 실행 시간이 길어짐

![image.png](https://github.com/user-attachments/assets/1b880641-b093-495e-b7cb-dd62e1b8f910)

- RAM 용량이 크다면?
    - 미리 RAM 에 저장할 수 있음
    - 많은 프로그램을 동시에 실행하는 데 유리함

![image.png](https://github.com/user-attachments/assets/9c32077a-9916-45be-8cb0-4d5679c38a41)

- RAM 용량이 무지막지하게 크다면?
    - 프로그램 실행 속도가 어느 정도 증가하는 것은 맞지만, 용량이 필요 이상으로 커졌을 때 속도가 그에 비례하여 증가하지는 않음

### RAM의 종류

---

크게 DRAM, SRAM, SDRAM, DDR SDRAM이 있다.

- `DRAM`
    - Dynamic RAM
    - 시간이 지나면 저장된 데이터가 점차 사라짐
    - 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화 (다시 저장) 해야함
    - 소비 전력이 비교적 낮고, 저렴하고, 집적도 높음 → 대용량으로 설계하기 용이
- `SRAM`
    - Static RAM
    - 저장된 데이터가 변하지 않음
    - SRAM은 DRAM 보다 일반적으로 속도도 더 빠름
    - 적도가 낮고, 소비 전력 크고 , 가격 더 비쌈

>💡 SRAM도 비휘발성 메모리이다. 전원이 공급되지 않으면 저장된 내용이 날아간다.

- `SDRAM`
    - SRAM과 관계가 없음
    - Synchronous Dynamic RAM
    - `클럭 신호와 동기화`된, 발전된 형태의 `DRAM`
    - 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음
- `DDR SDRAM`
    - Double Data Rite SDRAM
    - 가장 흔히 사용되는 RAM
    - `대역폭을 넓혀 속도를 빠르`게 만든 `SDRAM`
        - 대역폭 : 데이터를 주고받는 길의 너비
    - DDR SDRAM 은 SDR SDRAM 에 비해 대역폭이 두 배 넓음
    - DDR SDRAM 의 전송 속도가 `SDRAM` 보다 두 배가량 빠름
    - 한 클럭 하나씩 데이터를 주고받을 수 있는 SDRAM 을 SDR SDRAM(Single Data Rate SDRAM) 이라 부르기도 함

## 06-2. 메모리의 주소 공간

`물리 주소`는 메모리 하드웨어가 사용하는 주소이고, `논리 주소`는 CPU와 실행 중인 프로그램이 사용하는 주소이다.

![image.png](https://github.com/user-attachments/assets/33f11aad-20bb-4634-a063-45fbc359a212)

### 물리 주소와 논리 주소

---

> CPU와 실행 중인 프로그램은 `현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있을까?`
> - 메모리 몇 번지에 무엇이 저장되어 있는지 다 알지 못함
> - 메모리에 저장된 정보는 시시각각 변하기 때문
>    - 메모리에는 새롭게 실행되는 프로그램이 시시때때로 적재되고,
>    - 실행이 끝난 프로그램은 삭제됨
>    - 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소가 달라질 수 있

- `물리 주소`
    - 메모리 하드웨어가 사용하는 주소
- `논리 주소`
    - CPU와 실행 중인 프로그램이 사용하는 주소
    - 프로그램마다 같은 논리 주소가 얼마든지 있을 수 있음
    - 그리고 CPU는 이 `논리 주소`를 받아들이고, 해석하고, 연산함

CPU가 메모리와 상호작용하려면 논리 주소와 물리 주소 간의 변환이 이루어져야 한다.

**그렇다면 논리 주소는 어떻게 물리 주소로 변환될까?**

- `MMU(Memory Management Unit)` 라는 하드웨어에 의해 수행됨
- CPU와 주소 버스 사이에 위치한 메모리 관리 장치
- `물리 주소` = CPU가 발생시킨 논리 주소 + 베이스 레지스터 값
    - `베이스 레지스터` : 프로그램의 가장 작은 물리 주소, 즉 프로그램의 첫 물리 주소를 저장
    - `논리 주소` : 프로그램의 시작점으로부터 떨어진 거리

![image.png](https://github.com/user-attachments/assets/e00d38fc-6c80-485c-baf2-b305b11e7de6)

![image.png](https://github.com/user-attachments/assets/b4a77a8e-4523-4dbc-a6e2-fdf6e7f4a1e3)

### 메모리 보호 기법

---

- `한계 레지스터`
    - 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험
    - 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호
    - 논리 주소의 `최대 크기`를 저장
- 베이스 레지스터 값 ≤ `프로그램의 물리 주소 범위` < 베이스 레지스터 값 + 한계 레지스터 값 미만
- `CPU가 접근하려는 논리 주소 < 한계 레지스터가 저장한 값`
    - CPU는 메모리에 접근하기 전에 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사함
    - CPU가 한계 레지스터보다 높은 논리 주소에 접근하면 → 인터럽트(트랩) 발생시켜 실행을 중단

![image.png](https://github.com/user-attachments/assets/06017a5c-1ad0-415a-b469-6271fecc0112)

![image.png](https://github.com/user-attachments/assets/35155795-0007-411f-8584-39a81b0a54d3)

## 06-3. 캐시 메모리

CPU가 메모리에 접근하는 시간은 CPU 의 연산 속도보다 느리다. 메모리에 접근하는 시간을 극복하기 위한 저장 장치가 바로 `캐시 메모리`다.

### 저장 장치 계층 구조

---

> ① CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다. </br>
> ② 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.

일반적으로 컴퓨터는 다양한 저장 장치를 모두 사용한다.

</aside>

- `저장 장치 계층 구조`
    - 컴퓨터가 사용하는 저장 장치들을 `CPU 에 얼마나 가까운가`를 기준으로 계층적으로 나타냄

  ![image.png](https://github.com/user-attachments/assets/2645ac90-e7aa-4cbf-9fed-fcc821d2b58c)


### 캐시 메모리

---

- `캐시 메모리`
    - CPU와 메모리 사이에 위치하
    - 레지스터보다 용량이 크고 메모리보다 빠른 `SRAM` 기반의 저장 장치
    - CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생
        - 데이터를 미리 캐시 메모리로 가지고 와서 활용

![image.png](https://github.com/user-attachments/assets/ff791868-fea1-4fc3-8019-eb3c7c751b0b)

컴퓨터 내부에는 여러 개의 캐시 메모리가 있다. 그리고 이 캐시 메모리들은 CPU와 가까운 순서대로 계층을 구성한다.

- L1(level 1) 캐시 : 코어와 가장 가까운 캐시 메모리
- L2(level 2) 캐시 : 그다음 가까운 캐시 메모리
- L3(level 3) 캐시 : 그다음 가까운 캐시 메모리
    - 메모리의 용량 : L1 < L2 < L3
    - 속도 : L3 < L2 < L1
    - 가격 : L3 < L2 < L1
- CPU 가 메모리 내에 데이터가 필요하다고 판단하면 우선 L1 캐시에 해당 데이터가 있는지를 알아보
  고, 없다면 L2, L3 캐시 순으로 데이터를 검색한다.

![image.png](https://github.com/user-attachments/assets/8cb25f0b-5744-4a7e-9baa-c30a55bb3885)

### 참조 지역성 원리

---

- 캐시 히트
    - 자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용될 경우
- 캐시 미스
    - 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만, 예측이 틀려 메모리에서 필요한 데
      이터를 직접 가져와야 하는 경우
    - 캐시 메모리의 이점을 활용할 수 없음
    - 캐시 미스가 자주 발생하면 성능이 떨어짐
- 캐시 적중률
    - `캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수`)

캐시 메모리는 `참조 지역성의 원리`에 따라 메모리로부터 가져올 데이터를 결정한다.

> 참조 지역성 </br>
> ① CPU 는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다. </br>
> ② CPU 는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

**① CPU 는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.**

- CPU는 변수가 저장된 메모리 공간을 언제든 다시 참조할 수 있다
- 변수에 저장된 값은 일반적으로 한 번만 사용되지 않고 프로그램이 실행되는 동안 여러 번 사용된다.

**② CPU 는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.**

- 서로 관련 있는 데이터끼리 모여서 저장된다.
- 하나의 프로그램 내에서도 관련 있는 데이터들은 모여서 저장된다.
- `공간 지역성` : 접근한 메모리 공간 근처를 접근하려는 경향