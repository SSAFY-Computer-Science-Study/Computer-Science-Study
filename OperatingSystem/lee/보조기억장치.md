# Chapter 07. 보조기억장치

## 07-1. 다양한 보조기억장치

가장 대중적인 보조기억장치는 `하드 디스크`와 `플래시 메모리`(USB 메모리, SD 카드, SSD)이다.

### 하드 디스크

---

- 자기적인 방식으로 데이터 저장
- 하드 디스크를 `자기 디스크`(`magnetic disk`)의 일종으로 지칭함
- 실제로도 하드 디스크는 CD나 LP와 비슷하게 동작함
  - 동그란 원판에 데이터 저장
  - 회전시켜 뾰족한 리더기로 데이터 읽기
    ![image.png](https://github.com/user-attachments/assets/480b98b1-e3bf-4229-9403-310da186c208)

### **하드 디스크 구조**

---

- `플래터`(`platter`)
  - 동그란 원판
  - 자기 물질로 덮여있고, 수많은 N극(0)과 S극(1)을 저장함
- `스핀들`(`spindle`)
  - 회전시키는 구성 요소
  - `RPM`(Revolution Per Minute) : 스핀들이 플래터를 돌리는 속도
- `헤드`(`head`)
  - 플래터를 대상으로 데이터를 읽고 쓰는 구성 요소
  - 디스크 암에 부착되어 있음
- `디스크 암`(`disk arm`)
  - 헤드를 원하는 위치로 헤드를 이동시킴

많은 양의 데이터를 저장해야 하기 때문에 일반적으로 여러 겹의 플래터로 이루어진다.

플래터 양면을 모두 사용할 수 있다.

- 양면 플래터를 사용하면 위아래로 플래터당 두 개의 헤드가 사용됨

### **하드 디스크 구성 요소**

---

- **플래터**
  - 트랙과 섹터라는 단위로 데이터를 저장함
- **트랙**
  - 플래터를 여러 동심원으로 나누었을 때 그중 하나의 원을 트랙이라 부름
- **섹터**
  - 하드 디스크의 가장 작은 전송 단위
  - 트랙이 여러 조각으로 나뉘는데, 이 한 조각을 섹터라 부름
- **실린더**
  - 여러 겹의 플래터 상에서 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위
    ![image.png](https://github.com/user-attachments/assets/c47edbb4-3172-4b7d-974c-47f258c4a397)

> 💡**연속된 정보를 저장할 때는?**
>
> - 보통 한 실린더에 기록된다.
> - ex) 두 개의 플래터를 사용하는 하드 디스크에서 네 개 섹터에 걸쳐 > 데이터를 저장할 때 아래와 같이 데이터를 저장함
> - 첫 번째 플래터 윗면
> - 첫 번째 플래터 뒷면
> - 두 번째 플래터 윗면
> - 두 번째 플래터 뒷면
>
> **연속된 정보를 하나의 실린더에 기록하는 이유?**
>
> - 디스크 암을 움직이지 않고도 바로 데이터에 접근할 수 있기 때문

### 저장된 데이터에 접근하는 과정

---

하드 디스크가 저장된 데이터에 접근하는 시간은 크게 탐색 시간, 회전 지연, 전송 시간으로 나뉜다.

`성능`에 큰 영향을 끼치는 시간이다.

![image.png](https://github.com/user-attachments/assets/796b120a-5a49-4eb7-a712-7f1979c65f90)

- `탐색 시간`
  - 접근하려는 데이터가 저장된 트랙까지 `헤드를 이동`시키는 시간
- `회전지연`
  - 헤드가 있는 곳으로 `플래터를 회전`시키는 시간을 의미
- `전송 시간`
  - 하드 디스크와 컴퓨터 간에 `데이터를 전송`하는 시간을 의미

![image.png](https://github.com/user-attachments/assets/2bec8e84-f51b-493a-86f4-6396cde143e3)

### 플래시 메모리

---

- 플래시 메모리 기반의 보조기억 장치 또한 많이 사용함
- USB 메모리 , SD 카드, SSD 모두 플래시 메모리 기반의 보조기억장치

![image.png](https://github.com/user-attachments/assets/e56f8c90-b155-4f96-a3e5-62feeab9f2e8)

### 플래시 메모리 가장 작은 데이터 저장 단위

---

- **셀**
  - 플래시 메모리에서 `데이터를 저장`하는 가장 작은 단위
  - 이 셀이 모이고 모여 MB, GB, TB 용량을 갖는 저장 장치가 됨
  - 하나의 셀에 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리 종류가 나뉨
    - `SLC`(Single Level Cell) : 한 셀에 1 비트를 저장할 수 있는 플래시 메모리
    - `MLC`(Multiple Level Cell) : 한 셀에 2 비트를 저장할 수 있는 플래시 메모리
    - `TLC`(Triple Level Cell) : 한 셀에 3 비트를 저장할 수 있는 플래시 메모fl
  - 이는 플래시 메모리의 `수명 , 속도 , 가격`에 큰 영향을 끼침

### SLC 타입

---

- SLC 타입은 MLC, TLC 타입에 비해 비트의 빠른 입출력 가능
- 수명도 길어서 수만에서 수십만 번 가까이 데이터를 쓰고 지우고를 반복할 수 있음
- 용량 대비 가격이 높음
  - 혼자서 살면 감당해야 할 주거 비용이 커지는 것과 같음
- 보통 기업에서 데이터를 읽고 쓰기가 매우 많이 반복되며 고성능의 빠른 저장 장치가 필요한 경우에 사용

### MLC 타입

---

- 한 셀로 네 개의 정보를 표현할 수 있음 (2 비트)
- SLC 타입보다 일반적으로 속도와 수명은 떨어짐
- 대용화하기 유리함
  - 한 집에 한 명씩 사는 것보다 한 집에 두 명씩 사는것이 훨씬 더 많은 사람을 수용할 수 있는 것과 같은 이치
- 시중에서 사용되는 많은 플래시 메모리 저장 장치들이 MLC 타입으로 만들어짐

---

- 한 셀로 여덟 개의 정보를 표현할 수 있음 (3 비트)
- 속도와 수명은 떨어짐
- 용량 대비 가격도 저렴함
  - 한 집에 한 명씩 사는 것보다 한 집에 두 명씩 사는것이 훨씬 더 많은 사람을 수용할 수 있는 것과 같은 이치

### 플래시 메모리 다양한 저장 단위

---

- **페이지**
  - 셀들이 모여 만들어진 단위
  - 플래시 메모리에서 `읽기와 쓰기`는 `페이지` 단위로 이루어짐
- **블록**
  - 페이지가 모여 만들어진 단위
  - `삭제`는 페이지보다 큰 `블록` 단위로 이루어짐
- **플레인**
  - 블록이 모여 만들어진 단위
- **다이**
  - 플레인이 모여 만들어진 단위

> 💡`읽기/쓰기` 단위와 `삭제` 단위가 다르다는 것이 플래시 메모리의 가장 큰 특징
> 중 하나다.

![image.png](https://github.com/user-attachments/assets/355f4034-151c-4f91-8e31-56fec74608b5)

### 페이지 상태

---

- **Free 상태**
  - 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
- **Valid 상태**
  - 이미 유효한 데이터를 저장하고 있는 상태를 의미
- **Invalid 상태**
  - 쓰레기값이라 부르는 유효하지 않은 데이터를 저장하고 있는 상태

> 💡플래시 메모리는 하드 디스크와는 달리 `덮어쓰기가 불가능`하여 Valid 상태인 페이지에는 새 데이터를 저장할 수 없다.

</aside>

### 플래시 메모리 동작

---

- 블록 X 에 새로운 데이터 C 를 저장하면 오른쪽 아래와 같이 저장됨

![image.png](https://github.com/user-attachments/assets/2113e6de-d8b2-4dac-909f-ba0f54606716)

- 기존의 A만을 A' 로 수정하고 싶다면?
  - 플래시 메모리에서 덮어쓰기는 불가능하기 때문에 기존에 저장된 A는 `Invalid` 상태가 되어 더 이상 값이 유효하지 않은 쓰레기값이 됨
  - 새로운 A' 데이터가 저장되고, 결과적으로 블록 X 의 `Valid` 페이지는 B. C. A' 가 됨
    ![image.png](https://github.com/user-attachments/assets/36e75699-d8dd-4f79-830d-cd47f5f8a9ca)
- 쓰레기값을 저장하고 있는 공간은 사용하지 않을 공간인데도 불구하고 용량을 차지함
- A 만 지울 수도 없음
  - 삭제는 블록 단위로 수행되기 때문
- 그래서 최근 SSD 를 비롯한 플래시 메모리는 이런 쓰레기값을 정리하기 위해 `가비지 컬렉션` 기능을 제공함

> 💡**가비지 컬렉션** <br>
> ① 유효한 페이지들만을 새로운 블록으로 복사한 뒤 , <br>
> ② 기존의 블록을 삭제하는 기능 <br>
> = 블록 X 의 모든 유효한 페이지를 새로운 블록 Y 로 옮기고 블록 X 를 삭제하는 것
> ![image.png](https://github.com/user-attachments/assets/ad8dfd43-c0cc-47b0-b934-9abc500ba392)

## 07-2. RAID의 정의와 종류

> 💡**1TB 하드 디스크 네 개 동시에 사용하는 것 vs. 4TB 하드 디스크 하나를 사용하는 것**
>
> - 1TB 하드 디스크 네 개로 RAID를 구성하면 4TB 하드 디스크 한 개의 성능과 안전성을 능가할 수 있음
>   ![image.png](https://github.com/user-attachments/assets/237cf423-9f7c-4198-8f66-8dcdd4534fe9)

</aside>

### RAID의 정의

---

- 절대로 잃어버려서는 안 될 민감한 정보를 보관해야 한다면 어떻게 안전하게 관리할 것?
- `보조기억장치에도 수명이 있다`
  → 하드 디스크와 같은 보조기억장치에 어떻게든 저장하는 걸로 충분치 않다!
- 이럴 때 사용할 수 있는 방법 중 하나가 `RAID` 임
- `RAID (Redundant Array of Independent Disks)`
  - 하드 디스크와 SSD 를 사용하는 기술
  - 데이터의 안전성 혹은 높은 성능을 위해 `여러 개의 물리적 보조기억장치를` 마치 `하나의 논리적 보조기억장치처럼` 사용하는 기술을 의미함

![image.png](https://github.com/user-attachments/assets/277a6a93-7083-4666-90d1-33c4abd4666b)

### RAID의 종류

---

- RAID : 여러 개의 하드 디스크나 SSD 를 마치 하나의 장치처럼 사용하는 기술
- RAID를 구성하는 방법 (RAID 레벨)
  - RAID 0, RAID 1, RAID 2, RAID 3, RAID 4, RAID 5, RAID 6
  - 이로부터 파생된 RAID 10, RAID 50 등이 있음

### RAID 0

---

- 여러 개의 보조기억장치에 `데이터를 단순히 나누어 저장`하는 구성 방식
- 1TB 하드 디스크 네 개로 RAID 0 를 구성했을 때, 어떠한 데이터를 저장할 때 각 하드 디스크는 아래와 같이 번갈아 가며 데이터를 저장함
- 저장되는 데이터가 `하드 디스크 개수만큼 나뉘어 저장`되는 것

![image.png](https://github.com/user-attachments/assets/3986c4b6-91ea-44b0-a0cf-5a544f24e4a9)

- **스트라입**
  - 줄무늬처럼 분산되어 저장된 데이터를 `스트라입`이라 부름
- **스트라이핑**
  - 분산하여 저장하는 것

**장점**

- 스트라이핑되면 저장된 데이터를 읽고 쓰는 속도가 빨라짐
  - 여러 번에 걸쳐 읽고 썼을 데이터를 동시에 읽고 쓸 수 있기 때문
  - 4TB 저장 장치 한 개를 읽고 쓰는 속도가 RAID 0 로 구성된 ITB 저장 장치 네 개의 속도가 이론상 네 배가량 빠름

**단점**

- 저장된 정보가 안전하지 않음
- 하드 디스크 중 하나에 문제가 생긴다면 다른 모든 하드 디스크의 정보를 읽는 데 문제가 생길 수 있음

### RAID 1

---

- `복사본`을 만드는 방식
- 거울처럼 완전한 복사본을 만드는 구성이기에 `미러링` 이라고도 부름
- RAID 0 처럼 데이터 스트라이핑이 사용되긴 했지만, 어떠한 데이터를 쓸 때는 원본과 복사본 두 군데에 씀
- 속도는 RAID 0 보다 느림

![image.png](https://github.com/user-attachments/assets/f33cfeae-2c50-4e38-94bb-2d5094174161)

**장점**

- 복구가 매우 간단함
- 하나에 문제가 발생해도 잃어버린 정보를 금방 되찾을 수 있기 때문

**단점**

- 사용 가능한 용량이 적어지는 단점이 있음
- RAID 1 에서는 복사본이 만들어지는 용량만큼 사용자가 사용하지 못함
- 많은 양의 하드 디스크가 필요하게 되고 , 비용이 증가함

### RAID 4

---

- RAID 1 처럼 완전한 복사본을 만드는 대신 `오류를 검출하고 복구하기 위한 정보를 저장`
  한 장치를 두는 구성 방식
- `패리티 비트` : 오류를 검출하고 복구하기 위한 정보
- 패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고 , 오류가 있다면 복구함

![image.png](https://github.com/user-attachments/assets/352b30e5-e7af-415d-a227-2d56a033cc47)

**장점**

- RAID 4 는 RAID 1 보다 적은 하드 디스크로도 데이터를 안전하게 보관할 수 있음

**단점**

- 어떤 새로운 데이터가 저장될 때마다 패리티를 저장하는 디스크에도 데이터를 쓰게 되므로 `패리티를 저장하는 장치`에 `병목 현상`이 발생한다는 문제가 있음

### RAID 5

---

- `패리티 정보`를 `분산하여 저장`하는 방식
- RAID 4 의 문제인 병목 현상을 해소함

![image.png](https://github.com/user-attachments/assets/0d8a2f91-1cd1-43e4-8093-4ed2c0cb0b76)

### RAID 6

---

- 구성은 기본적으로 RAID 5 와 같으나, `서로 다른 두 개의 패리티`를 두는 방식
- 오류를 검출하고 복구할 수 있는 수단이 두 개가 생긴 셈
- RAID 6 은 RAID 44 RAID 5 보다 안전한 구성
- 다만 새로운 정보를 저장할 때마다 함께 저장할 패리티가 두 개이므로 , 쓰기 속도는 느림
- 데이터 저장 속도를 조금 희생하더라도 데이터를 더욱 안전하게 보관하고 싶을 때 사용하는 방식

![image.png](https://github.com/user-attachments/assets/570d4e40-a9e6-449f-a733-37d5dcce6ac1)

### ⚙️ RAID 종류 정리

![Image](https://github.com/user-attachments/assets/f7c8243d-0bff-49b1-99a4-c6431d83aab5)

### 📌 RAID 레벨별 계산 공식

- RAID 0

  - 가용 용량 = N × S
  - 손실 용량 = 0
  - 성능과 용량 극대화가 목적, 가용 용량은 모든 디스크의 용량 합과 동일

- RAID 1

  - 가용 용량 = S
  - 손실 용량 = (N - 1) × S
  - 데이터 보호를 위해 모든 디스크에 동일한 데이터를 저장, 가용 용량은 단일 디스크의 용량과 동일

- RAID 5

  - 가용 용량 = (N - 1) × S
  - 손실 용량 = S
  - 패리티 정보가 각 디스크에 분산 저장, 전체 디스크 수에서 하나를 제외한 나머지 디스크의 용량 합이 가용 용량.

- RAID 6
  - 가용 용량 = (N - 2) × S
  - 손실 용량 = 2 × S
  - 두 개의 패리티 정보가 각 디스크에 분산 저장, 전체 디스크 수에서 두 개를 제외한 나머지 디스크의 용량 합이 가용 용량.

### 💻 예시 문제 및 풀이

- 예시 1: RAID 0
  - 문제: 4개의 디스크가 있으며, 각 디스크의 용량이 1TB인 경우, RAID 0의 가용 용량은?
  - 풀이:
    - N = 4, S = 1TB
    - 가용 용량 = N × S = 4 × 1TB = 4TB
- 예시 2: RAID 1
  - 문제: 4개의 디스크가 있으며, 각 디스크의 용량이 2TB인 경우, RAID 1의 가용 용량은?
  - 풀이:
    - N = 4, S = 2TB
    - 가용 용량 = S = 2TB
- 예시 3: RAID 5
  - 문제: 5개의 디스크가 있으며, 각 디스크의 용량이 1TB인 경우, RAID 5의 가용 용량은?
  - 풀이:
    - N = 5, S = 1TB
    - 가용 용량 = (N - 1) × S = (5 - 1) × 1TB = 4TB
- 예시 4: RAID 6
  - 문제: 6개의 디스크가 있으며, 각 디스크의 용량이 1TB인 경우, RAID 6의 가용 용량은?
  - 풀이:
    - N = 6, S = 1TB
  - 가용 용량 = (N - 2) × S = (6 - 2) × 1TB = 4TB
