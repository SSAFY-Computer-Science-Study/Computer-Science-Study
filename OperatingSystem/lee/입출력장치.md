# Chapter 08. 입출력장치

## 08-1. 장치 컨트롤러와 장치 드라이버

장치 컨트롤러와 장치 드라이버라는 개념을 통해 다양한 외부 장치가 컴퓨터 내부와 어떻게 연결되고 소통하는지를 알아본다.

### 장치 컨트롤러

---

> 💡 **입출력장치는 CPU, 메모리보다 다루기가 더 까다롭다. 왜일까?**
> - **첫째 , 입출력장치에는 종류가 너무나도 많다.**
>    - 키보드 , 모니터 , USB 메모리 , CD-ROM, SSD, 마우스, 프린터, 스피커, 마이크 등
>   - 장치마다 속도 , 데이터 전송 형식 등도 다양함
> - **둘째, CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮음**
>    - `전송률` : 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표
>    - CPU와 메모리는 1 초에도 수많은 데이터를 주고받을 수 있지만, 키보드나 마우스는 같은 시간 동안 데이터를 조금씩만 주고받을 수 있음
>    - CPU나 메모리보다 전송률이 높은 경우도 있음
>        - 하지만 결과적으로 CPU나 메모리와 전송률이 비슷하지 않기 때문에 같은 어려움을 겪게 됨
> ![image.png](https://github.com/user-attachments/assets/974a4345-a919-4b03-829a-dcc201966472)


이와 같은 이유로 입출력장치는 컴퓨터에 직접 연결되지 않고 `장치 컨트롤러`라는 하드웨
어를 통해 연결된다.

장치 컨트롤러는 `입출력 제어기`, `입출력 모듈` 등으로 다양하게 불리기도 한다.

`모든` 입출력장치는 `각자의 장치 컨트롤러를 통해` 컴퓨터 내부와 정보를 주고받고, 장치 컨트롤러는
`하나 이상의 입출력장치와 연결`되어 있다.

### 장치 컨트롤러의 역할

---

- CPU와 입출력장치 간의 통신 중개
- 오류 검출
- 데이터 버퍼링

### 데이터 버퍼링이란?

---

- `버퍼링`
    - 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 `버퍼`라는 `임시 저장 공간`에 저장하여 전송률을 비슷하게 맞추는 방법
    - 쉽게 말해 `버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보내거나`, `데이터를 한 번에 많이 받아 조금씩 내보내는 방법`이라고 보면 됨
    - 즉 , `장치 컨트롤러`는 버퍼링을 통해 전송률이 높은 CPU 와 일반적으로 전송률이 낮은 입출력장치와의 `전송률 차이를 완화함`

![image.png](https://github.com/user-attachments/assets/0c0bf1c5-d3bb-4962-b98c-54f43a3a7c90)

### 장치 컨트롤러 내부

---

- `데이터 레지스터`
    - CPU 와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
    - 데이터 레지스터가 `버퍼` 역할을 함
    - 최근 주고받는 데이터가 많은 입출력장치에서는 레지스터 대신 `RAM`을 사용하기도 함
- `상태 레지스터`
    - 입출력장치가 입출력 작업을 할 준비가 되었는지 , 입출력 작업이 완료되었는지, 입출력장치에 오류는 없는지 등의 상태 정보가 저장됨
- `제어 레지스터`
    - 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장함

![image.png](https://github.com/user-attachments/assets/c08560e3-673d-459b-babe-9dcf71c690e4)

이 레지스터들에 담긴 값들은 버스를 타고 CPU나 다른 입출력장치로 전달되기도 하고, 장치 컨트롤
러에 연결된 입출력장치로 전달된다.

### 장치 드라이버

---

새로운 장치를 컴퓨터에 연결하려면 장치 드라이버를 설치해야 한다.

- 장치 드라이버
    - 장치 컨트롤러의 `동작을 감지하고 제어함`으로써 `장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게` 하는 `프로그램`
    - 프로그램이기에 당연히 실행 과정에서 메모리에 저장됨

> 💡 `장치 컨트롤러`가 입출력장치를 연결하기 위한 `하드웨어`적인 통로라면, `장치 드라이버`는 입출력장치를 연결하기 위한 `소프트웨어`적인 통로이다.

![image.png](https://github.com/user-attachments/assets/3308303f-51f0-4861-afc9-1c44c23ff6f4)

컴퓨터가 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 그 장치는 어떤 회사에서 만들어진 제품이든, 생김새가 어떻든 상관없이 컴퓨터 내부와 정보를 주고받을 수 있다. 반대로 장치 드라이버를 인식하거나 실행할 수 없는 상태라면 그 장치는 컴퓨터 내부와 정보를 주고받을 수 없다.

## 08-2. 다양한 입출력 방법

> 💡 입출력 작업을 수행하려면 CPU 와 장치 컨트롤러가 정보를 주고받아야 한다.
> **그렇다면 장치 컨트롤러는 CPU와 어떻게 정보를 주고받을까?**
> - 크게 세 가지 방법이 있다.
>    - 프로그램 입출력
>    - 인터럽트 기반 입출력
>    - DMA 입출력

### 프로그램 입출력

---

- `프로그램 입출력`은 기본적으로 프로그램 속 `명령어`로 입출력장치를 제어하는 방법
- CPU 가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면
→ CPU 는 입출력장치에 연결된 `장치 컨트롤러와 상호작용하며 입출력 작업을 수행`함

> 💡 ### 메모리에 저장된 정보를 하드 디스크에 백업하는 상황
> 1. 메모리에 저장된 정보를 `하드 디스크에 백업`한다 == `하드 디스크에 새로운 정보를 쓴다`와 같다. 우선 CPU 는 하드 디스크 컨트롤러의 `제어 레지스터`에 쓰기 명령을 보낸다.
>    ![image.png](https://github.com/user-attachments/assets/b2cbe29a-eab8-4ca5-ae1e-e43067fe8c20)
> 2. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인한다. 하드 디스크가 준비된 상태라면 하
드 디스크 컨트롤러는 `상태 레지스터에 준비되었다고 표시`한다.
>   ![image.png](https://github.com/user-attachments/assets/f7cc0417-e141-4e68-af2f-171427de2b6c)
    
3. ① CPU 는 상태 레지스터를 주기적으로 읽어보며 `하드 디스크의 준비 여부`를 확인한다.
② 하드 디스크가 준비됐음을 CPU가 알게 되면 백업할 메모리의 정보를 `데이터 레지스터`에 쓴다. 아직 백업 작업 ( 쓰기 작업 ) 이 끝나지 않았다면 01 번부터 반복하고, 쓰기가 끝났다면 작업을 종료한다.
    
    ![image.png](attachment:a49befcd-1ad9-43a7-bcb3-5af5483c3c8a:image.png)

이렇듯 프로그램 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 `레지스터 값을 읽고씀`으로써 이루어진다.

> 💡 **그런데 CPU 는 입출력장치들의 주소를 어떻게 아는 걸까?**
> **정확히 말해 CPU는 장치 컨트롤러의 레지스터들을 어떻게 아는 걸까?**
>
> - CPU는 여러 장치 컨트롤러 속 레지스터들을 모두 알고 있기 어려움
> - 명령어들은 `메모리 맵 입출력`과 `고립형 입출력`으로 표현되고 저장됨

### 메모리 맵 입출력

---

- `메모리 맵 입출력`
    - `메모리에 접근하기 위한 주소 공간`과 `입출력장치에 접근하기 위한 주소 공간`을 `하나`의 주소 공간으로 간주하는 방법
    - 1,024 개의 주소를 표현할 수 있는 컴퓨터가 있을 때  512개는 메모리 주소를, 512 개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용함
    
    ![image.png](https://github.com/user-attachments/assets/52ea895d-a6c5-4c4d-a6b7-a87ce55fb29b)
    
- 이때 중요한 점은 메모리 맵 입출력 방식에서 CPU 는 메모리의 주소들이나 장치 컨트롤러의 레지스
터들이나 `모두 똑같이 메모리 주소를 대하듯 하면 된다`는 점이다.
- 그래서 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없다.

### 고립형 입출력

---

- `고립형 입출력`
    - 메모리를 위한 주소 공간과 입출력장치를 위한 `주소 공간을 분리`하는 방법
    - 제어 버스에 `메모리 읽기 / 쓰기` 선 이외에 `입출력장치 읽기 / 쓰기` 선이 따로 있다면 메모리에도 1,024 개의 주소 공간을 활용하고 , 입출력장치도 1,024 개의 주소 공간을 활용할 수 있음
    - CPU 가 `메모리 읽기 / 쓰기` 선이 활성화되는 명령어를 실행할 때는 `메모리`에 접근하고, `입출력장치 읽기 / 쓰기` 선이 활성화되는 명령어를 실행할 때는 `장치 컨트롤러`에 접근함
    - 입출력장치에 접근하기 위해 사용하는 입출력 메모리는 메모리에 접근하는 명령어와는 다름
    
    ![image.png](https://github.com/user-attachments/assets/efdf23eb-0ca7-47ad-b373-b087fec67c17)
    
    ![image.png](https://github.com/user-attachments/assets/e680e28a-fd1c-48de-acfa-3e29f855117a)
    

### 인터럽트 기반 입출력

---

- `인터럽트 기반 입출력`

입출력장치에 의한 `하드웨어 인터럽트`는 정확히 말하자면 입출력장치가 아닌 `장치 컨트롤러에 의해 발생`한다. CPU 는 `장치 컨트롤러에 입출력 작업을 명령`하고, 장치 컨트롤러가 입출력장치를 제어하며 입출력을 수행하는 동안 `CPU 는 다른 일을 할 수` 있다.

![image.png](https://github.com/user-attachments/assets/05539f15-ff6d-4bdd-9c9b-33c17d1f68ef)

장치 컨트롤러가 입출력 작업을 끝낸 뒤 `CPU에게 인터럽트 요청 신호`를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행한다.

![image.png](https://github.com/user-attachments/assets/df747e61-9767-40fd-9b3f-21d8b304b5dc)

> 💡`폴링`
> - 인터럽트와 자주 비교되는 개념 중 폴링 (poling) 이라는 개념이 있다.
> - 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지를 `주기적으로 확인하는 방식`
> - 폴링 방식은 당연하게도 인터럽트 방식보다 CPU의 부담이 더 크다.
> - 인터럽트를 활용하면 CPU가 인터럽트 요청을 받을 때까지 온전히 다른 일에 집중할 수 있기 때문이다.

### 우선순위 고려

---

현실적으로 모든 인터럽트를 전부 `순차적으로만 해결할 수 없다`. 인터럽트 중에서도 더 빨리 처리해야 하는 인터럽트가 있기 때문이다.

- **CPU 는 인터럽트 간에 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 처리함**
    - 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우
    - 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 `NMI(Non-Maskable Interrupt)`가 발생한 경우

### 프로그래머블 인터럽트 컨트롤러 (Programable Iterrupt Contoller : PIC)

---

여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 `하드웨어 인터럽트 요청들의 우선순위를 판별`한 뒤 CPU에 `지금 처리해야 할 하드웨어 인터럽트는 무엇인지를 알려주는` 장치이다.

- PIC 에는 여러 핀이 있는데 , 각 핀에는 CPU에 하드웨어 인터럽트 요청을 보낼 수 있는 약속된 하드웨어가 연결되어 있음
- ex) 첫 번째 핀은 타이머 인터럽트를 받아들이는 핀, 두 번째 핀은 키보드 인터럽트를 받아들이는 핀

![image.png](https://github.com/user-attachments/assets/78da59da-dede-4fa8-a578-daea7a3a4f67)

![image.png](https://github.com/user-attachments/assets/572ba2e8-6e38-42b6-acae-87d8292962eb)

일반적으로 더 많고 복잡한 장치들의 인터럽트를 관리하기 위해 아래와 같이 PIC 를 두 개 이상 계층적으로 구성된다.

> 💡 PIC 가 `무시할 수 없는 인터럽트인 NMI 까지 우선순위를 판별하지는 않는다`.
> NMI 는 우선순위가 가장 높아 우선순위 판별이 불필요하기 때문이다.
> PIC 가 우선순위를 조정해 주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트이다.

### DMA 입출력

---

프로그램 기반 입출력과 인터럽트 기반 입출력에 공통점이 있다면 입출력장치와 메모리 간의 데이터 이동은 `CPU 가 주도`하고 , `이동하는 데이터도 반드시 CPU 를 거친다는 점`이다.

입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU 를 거쳐야 한다면 가뜩이나 바쁜
CPU 는 입출력장치를 위한 연산 때문에 시간을 뺏기게 된다. 하드 디스크 백업과 같이 대용량 데
이터를 옮길 때는 CPU 부담이 더욱 커진다. 그래서 `DMA`가 등장했다.

- `DMA(Direct Memory Acces)`
    - 입출력장치와 메모리가 CPU 를 거치지 않고도 상호작용할 수 있는 입출력 방식
    - 직접 메모리에 접근할 수 있는 입출력 기능
    - DMA 입출력을 하기 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다.

![image.png](https://github.com/user-attachments/assets/641d86e0-9cd5-453d-b9d2-47c5e45773b2)

![image.png](https://github.com/user-attachments/assets/1ab8f9e4-6b12-42a9-9cb0-06fac6896fc9)

> 💡 DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근이 가능하지만, `시스템 버스는 동시 사용이 불가능하다.`
> - 시스템 버스는 공용 자원이기 때문
> - CPU 가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없고, DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU 가 시스템 버스를 사용할 수 없음
> 그래서 DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스를 이용하거나 , CPU 가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용한다.

### 입출력 버스

---

CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 `모두 같은 버스를 공유하는 구성`에서는 DMA 를 위
해 한 번 메모리에 접근할 때마다 `시스템 버스를 두 번 사용하게 되는 부작용`이 있다.

- DMA 를 위해 시스템 버스를 너무 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못함

이 문제는 DMA 컨트롤러와 장치 컨트롤러들을 `입출력 버스` 라는 별도의 버스에 연결하여 해결할 수 있다. 장치 컨트롤러들이 시스템 버스가 아닌 입출력 버스로 DMA 컨트롤러에 연결된다면 DMA 컨트롤러와 장치 컨트롤러가 서로 데이터를 전송할 때는 시스템 버스를 이용할 필요가 없으므로 시스템 버스의 사용 빈도를 줄일 수 있다.

![image.png](attachment:7a7cabda-ea81-46b9-b58a-e31e13a9a012:image.png)

현대 대부분 컴퓨터에는 입출력 버스가 있다. 다시 말해 대부분의 입출력장치는 시스템 버스가 아닌 입출력 버스와 연결된다.

- 입출력 버스는 입출력장치를 컴퓨터 내부와 연결 짓는 통로라고도 볼 수 있음
- 입출력 버스에는 `PCI 버스` , `PCI Express(PCle) 버스` 등 여러 종류가 있음
    - `PCle 슬롯` : 여러 입출력장치들을 PCle 버스와 연결해 주는 통로

거의 모든 입출력장치들은 이렇게 `입출력 버스와 연결되는 통로`를 통해 `시스템 버스`를 타고 CPU 와 정보를 주고받는다.