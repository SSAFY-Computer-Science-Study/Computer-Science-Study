# Chapter 10. 프로세스와 스레드

## 10-1. 프로세스 개요

### 프로세스 직접 확인하기

---

- 프로세스

  - 보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로그램은 프로세스가 됨

  ![image.png](https://github.com/user-attachments/assets/b8e07bdc-18f4-4408-8570-b4235b3db1a7)

- 포그라운드 프로세스
  - 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스
  - 사용자가 보지 못하는 뒤에서 실행하는 프로세스
  - 데몬 - 유닉스 / 서비스 - 윈도우
    - 백그라운드 프로세스 중에서 사용자와 상호작용하지 않는 경우

```java
ps -ef
```

### 프로세스 제어 블록

---

모든 프로그램은 하드웨어를 필요로 한다. 계산하는 프로그램은 CPU를, 이미지를 하드 디스크에 저장하는 프로그램은 하드 디스크를 필요로 한다.

- 프로세스 제어 블록 (PCB)
  - 자원 배분을 위해 사용함
  - 프로세스와 관련된 정보를 저장하는 자료구조
  - 프로세스 식별자
  - `커널 영역`에 생성됨
- PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기된다.

> 💡 프로새스 생성 == 운영체제가 PCB 생성 == 프로세스가 종료됨 == 운영체제가 PCB 폐기

![image.png](https://github.com/user-attachments/assets/5415b6a7-d220-49be-975d-6ac9c0c70c31)

### 프로세스 ID

---

- 프로세스 ID
  - PID
  - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호

### 레지스터 값

---

- 프로세스가 자신의 차례가 되면 이전까지 사용했던 레지스터의 중간값들을 모두 복원한다. PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들이 담긴다.

### 프로세스 상태

---

- 상태
  - 입출력장치를 사용하기 위해 기다리는 상태
  - CPU를 사용하기 위해 기다리고 있는 상태
  - CPU를 이용하고 있는 상태
  - 등등

### CPU 스케줄링 정보

---

프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보

### 메모리 관리 정보

---

프로세스마다 메모리에 저장된 위치가 다르다. PCB에 프로세스가 어느 주소에 저장되어 있는지 담긴다.

- 베이스 레지스터, 한계 레지스터, 페이지 테이블 정보 등등도 담김

### 사용한 파일과 입출력 장치 목록

---

프로세스 실행 과정에서 어떤 입출력장치가 할당되었는지, 어떤 파일들을 열었는지 기록된다.

![image.png](https://github.com/user-attachments/assets/3b020a4f-fb92-4dc4-b3fb-45694fd4d22a)

### 문맥 교환

---

- 문맥
  - 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보
  - 하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있음

인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업한다. 그리고 뒤이어 실행할 프로세스 B의 문맥을 복구한다.

- 문맥 교환
  - 기존 프로세스 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
  - 문맥교환이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 수행되기 때문에 동시에 실행되는 것처럼 보임

![image.png](https://github.com/user-attachments/assets/9ea96229-c66b-44d7-95f4-4760cd0ff566)

### 프로세스의 메모리 영역

---

- 사용자 영역
  - 코드 영역
  - 데이터 영역
  - 힙 영역
  - 스택 영역

![image.png](https://github.com/user-attachments/assets/3b020a4f-fb92-4dc4-b3fb-45694fd4d22a)

### 코드 영역

---

- 텍스트 영역
- `실행할 수 있는 코드`, 즉 기계어로 이루어진 명령어가 저장됨
- 쓰기 금지
- `읽기 전용 공간`

### 데이터 영역

---

- 잠깐 썼다 없앨 데이터가 아닌 프로그램이 실행하는 동안 유지할 데이터가 저장되는 공간
  - 전역변수
- 정적 할당 영역
  - `코드` 영역과 `데이터` 영역은 크기가 변하지 않음 → 크기가 고정된 영역
- 동적 할당 영역
  - `힙` 영역과 `스택` 영역
  - 프로세스 실행 과정에서 그 크기가 변할 수 있는 영역

### 힙 영역

---

- 프로그래머가 직접 할당할 수 있는 저장 공간
- 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 함
- 반환하지 않는다면 메모리 낭비!! `메모리 누수` 발생!!

### 스택 영역

---

- 데이터를 일시적으로 저장하는 공간
- 잠깐 쓰다가 말 값들이 저장되는 공간
  - 매개 변수
  - 지역 변수
- PUSH, POP됨으로써 스택 영역에서 사라짐

> 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되고, 스택 영역은 높은 주소에서 낮은 주소로 할당된다. 그래야만 힙 영역과 스택 영역에 데이터가 쌓여도 새롭게 할당되는 주소가 겹칠 일이 없다.
>
> ![image.png](https://github.com/user-attachments/assets/9ea96229-c66b-44d7-95f4-4760cd0ff566) > ![Image](https://github.com/user-attachments/assets/80a9afff-4ad9-46b9-9c84-dc22bc8907c7)

## 10-2. 프로세스 상태와 계층 구조

### 프로세스 상태

---

프로세스는 모두 저마다의 상태가 있다. 이런 프로세스의 상태를 운영체제가 PCB에 기록하여 관리한다.

### 생성 상태

---

- 프로세스를 생성 중인 상태 (new)
- 막 메모미에 적재되어 PCB를 할당 받은 상태
- 곧바로 실행되지 않고 `준비` 상태가 되어 CPU의 할당을 기다림

### 준비 상태

---

- CPU를 할당받아 실행할 수 있지만, 자신의 차례가 아니기에 기다리고 있는 상태
- 차례가 되면 CPU를 할당받아 `실행` 상태가 됨

### 실행 상태

---

- running
- CPU를 할당 받아 실행 중인 상태
- 일정 시간동안만 CPU 이용 가능
- 할당된 시간을 모두 사용한다면 다시 `준비` 상태가 되고, 실행 도중 입출력 장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 한다면 `대기` 상태가 됨

### 대기 상태

---

- 입출력 장치의 작업을 기다리는 상태
- blocked
- 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다림

### 종료 상태

---

- terminated
- 프로세스가 종료된 상태
- 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함

### 프로세스 상태 다이어그램

![Image](https://github.com/user-attachments/assets/1cef10e4-5f68-48b5-9fc0-99f7a28e22c7)

### 프로세스 계층 구조

---

- 부모 프로세스
  - 새 프로세스를 생성한 프로세스
- 자식 프로세스
  - 부모 프로세스에 의해 생성된 프로세스

부모와 자식 프로세스는 각기 다른 PID를 가진다. 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID(Parent PID)가 기록되기도 한다.

많은 운영체제는 이처럼 프로세스가 프로세스를 낳는 계층적인 구조로서 프로세스들을 관리한다.

컴퓨터가 부팅될 때 실행되는 최초의 프로세스가 자식 프로세스들을 생성하고, 생성된 자식 프로세스들이 새로운 프로세스들을 낳는 형식으로 여러 프로세스가 동시에 실행되는 것이다.

![Image](https://github.com/user-attachments/assets/79d40f84-5b79-4f1d-90e3-de7c28e58762)

### 프로세스 생성 기법

---

> 자식 프로세스들은 **복제와 옷 갈아입기**를 통해 실행된다.

부모 프로세스는 `fork`를 통해 자신의 복사본을 자식 프로세스로 생성해내고, 만들어진 복사본(자식 프로세스)은 `exec`를 통해 자신의 메모리 공간을 다른 프로그램으로 교체한다.

fork와 exec는 시스템 호출이다.

- `fork`
  - 자기 자신 프로세스의 복사본을 만드는 시스템 호출
  - 복사본이기 때문에 부모 프로세스의 자원들, 이를테면 메모리 내용, 열린 파일의 목록 등이 상속됨
  - `복사된 자식프로세스라 할지라도 PID 값이나 저장된 메모리 위치는 다름!`

![Image](https://github.com/user-attachments/assets/3eb63415-12fe-422e-a064-ca918c152fd9)

- `exec`
  - 새로운 프로그램으로 전환됨
  - 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출
  - `덮어 써진다 == 자식 프로세스가 새로운 옷으로 갈아입었다`
    ![Image](https://github.com/user-attachments/assets/d2bb9ebb-e85b-47c6-b6ec-f998b8697305)
    > 💡 fork한 뒤에, 부모 프로세스, 자식 프로세스 누구도 exec를 호출하지 않는 경우
    >
    > - 부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행하는 프로세스

## 10-3. 스레드

### 프로세스와 스레드

---

- 스레드

  - 프로세스를 구성하는 실행의 흐름 단위
  - 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있음
    ![Image](https://github.com/user-attachments/assets/3ebf2b64-4730-4ad7-a8f3-914a33197ca1)

        > 💡 실행의 흐름 단위가 하나 == 프로세스들은 단일 스레드 프로세스라 볼 수 있음
        >
        > ![Image](https://github.com/user-attachments/assets/21e9b50a-daaa-410e-a01e-e8c0dd6c7721)
        >
        > 스레드라는 개념이 도입되면서, 하나의 프로세스가 여러 일을 동시에 처리할 수 있게 됨
        >
        > 즉, 프로세스를 구성하는 여러 명령어를 동시에 실행할 수 있게 됨
        >
        > ![Image](https://github.com/user-attachments/assets/203f4b4e-073f-418f-832a-130f91660b8b)
        >
        > - `스레드 == 프로세스를 구성하는 실행 단위`

        - 스레드의 구성 단위
          - 스레드 ID
          - 프로그램 마운터 값을 비롯한 레지스터 값
          - 스택

        각자 다른 자원을 가지고 있기에 스레드마다 각기 다른 코드를 실행할 수 있다.

        - `프로세스의 스레드들은 실행에 필요한 최소한의 정보만을 유지하면서!!

    프로세스의 자원을 공유한다!!!`

        ![Image](https://github.com/user-attachments/assets/39f0329e-b1c4-48d0-a260-d26d335d6726)

### 멀티 프로세스와 멀티 스레드

---

- 멀티 프로세스
  - 여러 프로세스를 동시에 실행하는 것
- 멀티 스레드
  - 여러 스레드로 프로세스를 동시에 실행하는 것

> 💡그렇다면, 동일한 작업을 수행하는 단일 스레드 프로세스를 여러 개 실행하는 것과 하나의 프로세스를 여러 스레드로 실행하는 것은 무엇이 다를까?
>
> - 프로세스 → 자원 공유 x
>   fork하면 동일한 내용이 메모리에 중복 적재됨
> - 스레드 → 자원 공유 o
>   메모리 효율적 / 협력과 통신에 유리함
>   다만, 문제가 생성하면 프로세스 전체에 문제가 생길 수도 있음

![image.png](https://github.com/user-attachments/assets/203f4b4e-073f-418f-832a-130f91660b8b)

![image.png](https://github.com/user-attachments/assets/d9a1ae45-1e75-4e0d-9958-665c75009504)

![image.png](https://github.com/user-attachments/assets/4351d47d-9576-41fd-b788-7d101fbdcda5)

> 💡프로세스들끼리 소통하려면?
> IPC
>
> - 파일을 통한 소통
>   공유 메모리를 두어 주고 받기
>   소켓
>   파이프
>   등등
